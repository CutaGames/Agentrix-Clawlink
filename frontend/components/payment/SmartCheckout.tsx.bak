'use client';

import React, { useState, useEffect, useRef } from 'react';
import {
  Zap,
  CreditCard,
  Wallet,
  ShieldCheck,
  ChevronRight,
  Loader2,
  Fingerprint,
  Settings,
  History,
  AlertCircle,
  CheckCircle2,
  Smartphone,
  Globe,
  X as XIcon,
} from 'lucide-react';
import { useRouter } from 'next/router';
import { SessionKeyManager } from '@/lib/session-key-manager';
import { paymentApi } from '@/lib/api/payment.api';
import { userApi } from '@/lib/api/user.api';
import { useSessionManager } from '@/hooks/useSessionManager';
import { useWeb3 } from '@/contexts/Web3Context';
import { SessionManager } from './SessionManager';
import { AgentrixLogo } from '../common/AgentrixLogo';
import { TransakWhiteLabelModal } from './TransakWhiteLabelModal';
import { ethers } from 'ethers';

interface SmartCheckoutProps {
  order: {
    id: string;
    amount: number;
    currency: string;
    description: string;
    merchantId: string;
    to?: string; // æ”¶æ¬¾åœ°å€
    metadata?: Record<string, any>; // è®¢å•å…ƒæ•°æ®
  };
  onSuccess?: (result: any) => void;
  onCancel?: () => void;
}

type RouteType = 'quickpay' | 'provider' | 'wallet' | 'local-rail' | 'crypto-rail';
type Status = 'loading' | 'ready' | 'processing' | 'success' | 'error';

const TESTNET_NETWORK = {
  name: 'BSC Testnet',
  chainIdHex: '0x61',
  note: 'è¯·ä½¿ç”¨ BSC æµ‹è¯•ç½‘çš„ USDT ä¸ BNB Gas è¿›è¡Œæ”¯ä»˜è°ƒè¯•',
};

const DEFAULT_BSC_TESTNET_RPC =
  process.env.NEXT_PUBLIC_BSC_TESTNET_RPC_URL || 'https://bsc-testnet.publicnode.com';

const TOKEN_CONFIG: Record<
  string,
  {
    address: `0x${string}`;
    fallbackDecimals: number;
  }
> = {
  USDT: {
    address:
      (process.env.NEXT_PUBLIC_BSC_TESTNET_USDT_ADDRESS as `0x${string}`) ||
      '0x337610d27c682E347C9cD60BD4b3b107C9d34dDd',
    fallbackDecimals: 18,
  },
  USDC: {
    address:
      (process.env.NEXT_PUBLIC_BSC_TESTNET_USDC_ADDRESS as `0x${string}`) ||
      '0x64544969ed7EBf5f083679233325356EbE738930',
    fallbackDecimals: 6,
  },
};

const ERC20_ABI = [
  'function transfer(address to, uint256 amount) external returns (bool)',
  'function decimals() external view returns (uint8)',
];

interface ProviderOption {
  id: string;
  name: string;
  price: number;
  currency: string;
  requiresKYC: boolean;
  provider: string;
  estimatedTime?: string;
  fee?: number; // æ€»è´¹ç”¨ï¼ˆProvider è´¹ç”¨ + Agentrix å¹³å°è´¹ç”¨ï¼Œå¦‚æœä¸º 0 è¡¨ç¤ºæœªè·å–åˆ°æŠ¥ä»·ï¼‰
  providerFee?: number; // Provider è´¹ç”¨ï¼ˆä»… Provider æ”¶å–çš„è´¹ç”¨ï¼‰
  agentrixFee?: number; // Agentrix å¹³å°è´¹ç”¨ï¼ˆé¢å¤–æ”¶å–çš„å¹³å°è´¹ç”¨ï¼‰
  commissionContractAddress?: string; // åˆ†æ¶¦ä½£é‡‘åˆçº¦åœ°å€ï¼ˆProvider å…‘æ¢åè‡ªåŠ¨æ‰“å…¥æ­¤åœ°å€ï¼‰
  minAmount?: number; // æœ€ä½å…‘æ¢é‡‘é¢ï¼ˆå¦‚æœè®¢å•é‡‘é¢ä½äºæ­¤å€¼ï¼Œåº”æ˜¾ç¤ºæ­¤æœ€ä½é‡‘é¢ï¼‰
  available?: boolean; // æ˜¯å¦å¯ç”¨ï¼ˆå¦‚æœè®¢å•é‡‘é¢ä½äºæœ€ä½é‡‘é¢ï¼Œåˆ™ä¸º falseï¼‰
}

interface PreflightResult {
  recommendedRoute: RouteType;
  quickPayAvailable: boolean;
  sessionLimit?: {
    singleLimit: string;
    dailyLimit: string;
    dailyRemaining: string;
  };
  walletBalance?: string;
  walletBalanceIsMock?: boolean; // æ ‡è®°ä½™é¢æ˜¯å¦ä¸º mock å€¼
  requiresKYC?: boolean;
  estimatedTime?: string;
  fees?: {
    gasFee?: string;
    providerFee?: string;
    total?: string;
  };
  providerOptions?: ProviderOption[]; // å„æ”¯ä»˜æ–¹å¼çš„ä»·æ ¼å’Œ KYC è¦æ±‚
}

const formatFiatSymbol = (currency?: string) => {
  const code = currency?.toUpperCase() || 'USD';
  switch (code) {
    case 'CNY':
    case 'JPY':
      return 'Â¥';
    case 'EUR':
      return 'â‚¬';
    case 'GBP':
      return 'Â£';
    case 'USD':
    default:
      return '$';
  }
};

const formatFiatAmount = (value: number, currency?: string) => {
  const code = currency?.toUpperCase() || 'USD';
  const digits = code === 'JPY' ? 0 : 2;
  return `${formatFiatSymbol(code)}${value.toFixed(digits)} ${code}`;
};

export function SmartCheckout({ order, onSuccess, onCancel }: SmartCheckoutProps) {
  const router = useRouter();
  const [status, setStatus] = useState<Status>('loading');
  const [routeType, setRouteType] = useState<RouteType>('quickpay');
  const [preflightResult, setPreflightResult] = useState<PreflightResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [currentSession, setCurrentSession] = useState<any>(null);
  const [userProfile, setUserProfile] = useState<any>(null);
  const [showKYCGuide, setShowKYCGuide] = useState(false);
  const [showQuickPayGuide, setShowQuickPayGuide] = useState(false);
  const [showSessionManager, setShowSessionManager] = useState(false);
  const [showProviderModal, setShowProviderModal] = useState(false);
  const [selectedProviderOption, setSelectedProviderOption] = useState<ProviderOption | null>(null);
  const { activeSession, loadActiveSession } = useSessionManager();
  const { isConnected, defaultWallet, connect, connectors } = useWeb3();
  const tokenMetadataCache = useRef<Record<string, { address: string; decimals: number }>>({});
  const providerModalAutoOpened = useRef(false);

  const normalizedCurrency = (order.currency || 'USDC').toUpperCase();
  const isFiatOrderCurrency = ['CNY', 'USD', 'EUR', 'GBP', 'JPY'].includes(normalizedCurrency);
  // æ³¨æ„ï¼šå•†å®¶æ¥ä¸æ¥å— crypto ä¸å½±å“è·¯ç”±é€‰æ‹©ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ offramp è½¬æ¢
  // æœ€ç»ˆéƒ½æ˜¯è½¬æ¢æˆæ•°å­—è´§å¸é€šè¿‡åˆçº¦åˆ†ä½£
  const merchantConfig = order.metadata?.merchantPaymentConfig || 'both';
  const merchantAllowsCrypto = merchantConfig === 'both' || merchantConfig === 'crypto_only';
  const providerOptions = preflightResult?.providerOptions || [];
  const topFiatOptions = providerOptions.slice(0, 4);
  const hasFiatOptions = topFiatOptions.length > 0;
  
  // åˆ¤æ–­æ˜¯å¦è·¨å¢ƒï¼ˆæœªæ¥ç”¨äºé€‰æ‹©æœ¬åœ°é€šé“ï¼‰
  // ç›®å‰æš‚æœªå®ç°æœ¬åœ°é€šé“ï¼Œæ‰€æœ‰æ³•å¸æ”¯ä»˜éƒ½é€šè¿‡ Transak
  const isCrossBorder = order.metadata?.isCrossBorder || false;
  const userCountry = order.metadata?.userCountry;
  const merchantCountry = order.metadata?.merchantCountry;

  const resolveEthersProvider = () => {
    if (typeof window !== 'undefined' && (window as any).ethereum) {
      return new ethers.BrowserProvider((window as any).ethereum);
    }
    return new ethers.JsonRpcProvider(DEFAULT_BSC_TESTNET_RPC);
  };

  const getTokenMetadata = async (symbol: string) => {
    const tokenSymbol = symbol?.toUpperCase();
    if (!tokenSymbol) {
      throw new Error('æœªæŒ‡å®šæ”¯ä»˜ä»£å¸');
    }

    if (tokenMetadataCache.current[tokenSymbol]) {
      return tokenMetadataCache.current[tokenSymbol];
    }

    const config = TOKEN_CONFIG[tokenSymbol];
    if (!config?.address) {
      throw new Error(`æš‚ä¸æ”¯æŒ ${tokenSymbol} æ”¯ä»˜ï¼Œè¯·è”ç³»å•†å®¶æˆ–å®¢æœ`);
    }

    let decimals = config.fallbackDecimals;
    try {
      const provider = resolveEthersProvider();
      const contract = new ethers.Contract(config.address, ERC20_ABI, provider);
      const onChainDecimals = await contract.decimals();
      decimals = Number(onChainDecimals);
    } catch (error) {
      console.warn(`è·å– ${tokenSymbol} ç²¾åº¦å¤±è´¥ï¼Œä½¿ç”¨å…œåº•å€¼ ${decimals}`, error);
    }

    const metadata = { address: config.address, decimals };
    tokenMetadataCache.current[tokenSymbol] = metadata;
    return metadata;
  };
  
  // æ±‡ç‡ç›¸å…³çŠ¶æ€
  const [exchangeRate, setExchangeRate] = useState<number | null>(null);
  const [cryptoAmount, setCryptoAmount] = useState<number | null>(null);
  const [exchangeRateLockId, setExchangeRateLockId] = useState<string | null>(null);
  const [isLoadingExchangeRate, setIsLoadingExchangeRate] = useState(false);

  // å…ˆåŠ è½½ç”¨æˆ·ä¿¡æ¯å’Œæ´»è·ƒ Sessionï¼Œç„¶åæ‰§è¡Œ Pre-Flight Check
  useEffect(() => {
    const initializePayment = async () => {
      try {
        setStatus('loading');
        
        // 1. åŠ è½½ç”¨æˆ·ä¿¡æ¯ï¼ˆæ£€æŸ¥ KYC çŠ¶æ€ï¼‰
        try {
          const profile = await userApi.getProfile();
          setUserProfile(profile);
          console.log('Loaded user profile:', profile);
        } catch (error) {
          console.warn('Failed to load user profile:', error);
        }
        
        // 2. å…ˆåŠ è½½æ´»è·ƒ Sessionï¼ˆå¦‚æœå·²è¿æ¥é’±åŒ…ï¼‰
        let session = null;
        if (isConnected) {
          try {
            session = await loadActiveSession();
            if (session) {
              setCurrentSession(session);
            }
            console.log('Loaded active session:', session);
          } catch (error) {
            console.warn('Failed to load active session:', error);
          }
        }
        
        // ä¹Ÿä½¿ç”¨ useSessionManager è¿”å›çš„ activeSession
        if (activeSession) {
          setCurrentSession(activeSession);
        }

        // 2. æ‰§è¡Œ Pre-Flight Check
        try {
          const result = await paymentApi.preflightCheck({
            amount: order.amount.toString(),
            currency: order.currency || 'USDC',
          });

          console.log('Pre-flight check result:', result);
          setPreflightResult(result);

          const finalSession = session || activeSession || currentSession;
          const hasWallet = isConnected && defaultWallet;
          const hasQuickPaySession = Boolean(finalSession);
          const quickPayEligible = hasQuickPaySession && result.quickPayAvailable;
          
          // ========== è·¯ç”±é€‰æ‹©æ ¸å¿ƒé€»è¾‘ ==========
          // æ ¸å¿ƒæ¡ä»¶ï¼šç”¨æˆ·æ˜¯å¦æœ‰é’±åŒ…
          // 
          // 1. å¦‚æœæœ‰é’±åŒ…ï¼š
          //    - ä¼˜å…ˆä½¿ç”¨ QuickPayï¼ˆå¦‚æœå¯ç”¨ï¼‰
          //    - å¦åˆ™ä½¿ç”¨é’±åŒ…æ”¯ä»˜
          //    - æ— è®ºè®¢å•æ˜¯æ³•å¸è¿˜æ˜¯cryptoï¼Œéƒ½å¯ä»¥é€šè¿‡æ±‡ç‡è½¬æ¢
          // 
          // 2. å¦‚æœæ²¡æœ‰é’±åŒ…ï¼š
          //    - èµ° Provider é€šé“ï¼ˆTransakï¼‰
          //    - é€šè¿‡ Transak è´­ä¹°åŠ å¯†è´§å¸ï¼Œç„¶åé€šè¿‡åˆçº¦åˆ†ä½£
          //    - å•†å®¶æ¥ä¸æ¥å— crypto æ²¡å…³ç³»ï¼Œå› ä¸ºæœ€ç»ˆéƒ½ä¼šè½¬æ¢æˆæ•°å­—è´§å¸
          // 
          // æœªæ¥ä¼˜åŒ–ï¼š
          // - å¦‚æœä¹°å–æ–¹åœ¨åŒä¸€å›½å®¶ï¼ˆæˆ–ç»Ÿä¸€æ³•å¸åŒºå¦‚æ¬§ç›Ÿï¼‰ï¼Œä½¿ç”¨æœ¬åœ°é€šé“ï¼ˆæ€§ä»·æ¯”æ›´é«˜ï¼‰
          // ======================================
          
          if (quickPayEligible) {
            // ä¼˜å…ˆï¼šæœ‰ QuickPay Session ä¸”é™é¢å†…
            setRouteType('quickpay');
            setCurrentSession(finalSession);
            console.log('âœ… æ£€æµ‹åˆ° QuickPay Session ä¸”é™é¢å†…ï¼Œä¼˜å…ˆä½¿ç”¨ QuickPay');
          } else if (hasWallet) {
            // ç”¨æˆ·æœ‰é’±åŒ…ï¼šä¼˜å…ˆä½¿ç”¨é’±åŒ…æ”¯ä»˜
            // æ— è®ºè®¢å•æ˜¯æ³•å¸è¿˜æ˜¯cryptoï¼Œéƒ½å¯ä»¥é€šè¿‡æ±‡ç‡è½¬æ¢
            if (result.quickPayAvailable && !finalSession) {
              // QuickPay å¯ç”¨ä½†è¿˜æ²¡æœ‰ Sessionï¼Œæ˜¾ç¤ºå¼•å¯¼
              setRouteType('wallet');
              setTimeout(() => {
                setShowQuickPayGuide(true);
              }, 500);
              console.log('QuickPay available but no session, showing guide');
            } else {
              setRouteType('wallet');
              console.log('âœ… ç”¨æˆ·æœ‰é’±åŒ…ï¼Œä½¿ç”¨é’±åŒ…æ”¯ä»˜ï¼ˆå¯é€šè¿‡æ±‡ç‡è½¬æ¢å¤„ç†æ³•å¸è®¢å•ï¼‰');
            }
          } else {
            // ç”¨æˆ·æ²¡æœ‰é’±åŒ…ï¼šèµ° Provider é€šé“ï¼ˆTransakï¼‰
            // é€šè¿‡ Transak è´­ä¹°åŠ å¯†è´§å¸ï¼Œç„¶åé€šè¿‡åˆçº¦åˆ†ä½£
            // å•†å®¶æ¥ä¸æ¥å— crypto æ²¡å…³ç³»ï¼Œå› ä¸ºæœ€ç»ˆéƒ½ä¼šè½¬æ¢æˆæ•°å­—è´§å¸
            setRouteType('provider');
            console.log('âœ… ç”¨æˆ·æ²¡æœ‰é’±åŒ…ï¼Œä½¿ç”¨ Provider é€šé“ï¼ˆTransakï¼‰è´­ä¹°åŠ å¯†è´§å¸');
          }

          setStatus('ready');
        } catch (error: any) {
        console.error('Pre-flight check failed:', error);
          // é™çº§å¤„ç†ï¼špreflight å¤±è´¥æ—¶ï¼Œæ ¹æ®ç”¨æˆ·æ˜¯å¦æœ‰é’±åŒ…å†³å®š
          const finalSession = session || activeSession || currentSession;
          if (isConnected && defaultWallet) {
            // ç”¨æˆ·æœ‰é’±åŒ…ï¼Œä½¿ç”¨é’±åŒ…æ”¯ä»˜
            setRouteType('wallet');
            console.log('Pre-flight failed, using wallet payment (user has wallet)');
          } else {
            // ç”¨æˆ·æ²¡æœ‰é’±åŒ…ï¼Œä½¿ç”¨ Provider é€šé“
            setRouteType('provider');
            console.log('Pre-flight failed, using provider payment (user has no wallet)');
          }
          setStatus('ready');
        }
      } catch (error: any) {
        console.error('Payment initialization failed:', error);
        setError(error.message || 'Failed to initialize payment');
        setStatus('ready');
      }
    };

    initializePayment();
  }, [order.amount, order.currency, order.metadata?.merchantPaymentConfig, isConnected, merchantAllowsCrypto]);

  useEffect(() => {
    if (!selectedProviderOption && preflightResult?.providerOptions?.length) {
      setSelectedProviderOption(preflightResult.providerOptions[0]);
    }
  }, [preflightResult, selectedProviderOption]);

  useEffect(() => {
    const requiresCryptoSettlement =
      isFiatOrderCurrency &&
      merchantAllowsCrypto &&
      (routeType === 'quickpay' || routeType === 'wallet');

    let isMounted = true;

    if (!requiresCryptoSettlement) {
      setExchangeRate(null);
      setCryptoAmount(null);
      setExchangeRateLockId(null);
      setIsLoadingExchangeRate(false);
      return () => {
        isMounted = false;
      };
    }

    const fetchExchangeRate = async () => {
      setIsLoadingExchangeRate(true);
      try {
        const rateInfo = await paymentApi.getExchangeRate(normalizedCurrency, 'USDT');
        if (!isMounted) {
          return;
        }
        setExchangeRate(rateInfo.rate);
        setCryptoAmount(order.amount * rateInfo.rate);
        console.log(
          'æ±‡ç‡è·å–æˆåŠŸ:',
          rateInfo.rate,
          'è½¬æ¢é‡‘é¢:',
          order.amount * rateInfo.rate,
        );
      } catch (error) {
        console.warn('è·å–æ±‡ç‡å¤±è´¥:', error);
        const defaultRate =
          normalizedCurrency === 'CNY'
            ? 0.142
            : normalizedCurrency === 'USD'
            ? 1.0
            : 0.142;
        if (isMounted) {
          setExchangeRate(defaultRate);
          setCryptoAmount(order.amount * defaultRate);
        }
      } finally {
        if (isMounted) {
          setIsLoadingExchangeRate(false);
        }
      }
    };

    if (exchangeRate === null || cryptoAmount === null) {
      fetchExchangeRate();
    }

    return () => {
      isMounted = false;
    };
  }, [
    routeType,
    merchantAllowsCrypto,
    isFiatOrderCurrency,
    normalizedCurrency,
    order.amount,
    exchangeRate,
    cryptoAmount,
  ]);

  const handlePay = async () => {
    console.log('ğŸ”µ handlePay called, status:', status, 'routeType:', routeType);
    
    if (status === 'processing') {
      console.log('âš ï¸ Already processing, ignoring click');
      return;
    }

    setError(null);
    
    console.log('ğŸš€ Starting payment process...');

    try {
      if (routeType === 'provider') {
        await handleProviderPay('transak', selectedProviderOption || undefined);
        return;
      }

      setStatus('processing');

      if (routeType === 'quickpay') {
        await handleQuickPay();
      } else if (routeType === 'wallet') {
        await handleWalletPay();
      } else {
        throw new Error('Unsupported payment route');
      }
    } catch (error: any) {
      console.error('Payment failed:', error);
      setError(error.message || 'Payment failed');
      setStatus('error');
    }
  };

  const handleQuickPay = async () => {
    const session = currentSession || activeSession;
    if (!session) {
      throw new Error('No active session found. Please create a session first.');
    }
    
    console.log('Executing QuickPay with session:', session);

    // 1. æ£€æŸ¥æ˜¯å¦éœ€è¦é”å®šæ±‡ç‡ï¼ˆå•†å®¶æŒ‚æ³•å¸ï¼Œç”¨æˆ·ç”¨æ•°å­—è´§å¸æ”¯ä»˜ï¼‰
    let paymentAmount = order.amount;
    let paymentCurrency = order.currency || 'USDC';
    let lockId = exchangeRateLockId;
    
    const currency = order.currency || 'USDC';
    const isFiatCurrency = ['CNY', 'USD', 'EUR', 'GBP', 'JPY'].includes(currency.toUpperCase());
    
    if (isFiatCurrency && exchangeRate && cryptoAmount) {
      // å¦‚æœè¿˜æ²¡æœ‰é”å®šæ±‡ç‡ï¼Œå…ˆé”å®š
      if (!lockId) {
        try {
          const lockResult = await paymentApi.lockExchangeRate({
            from: currency,
            to: 'USDT',
            amount: order.amount,
            expiresIn: 600, // 10åˆ†é’Ÿ
          });
          lockId = lockResult.lockId;
          setExchangeRateLockId(lockId);
          paymentAmount = lockResult.cryptoAmount;
          paymentCurrency = 'USDT';
          console.log('æ±‡ç‡å·²é”å®š:', lockId, 'æ”¯ä»˜é‡‘é¢:', paymentAmount, paymentCurrency);
        } catch (error) {
          console.error('é”å®šæ±‡ç‡å¤±è´¥:', error);
          // å¦‚æœé”å®šå¤±è´¥ï¼Œä½¿ç”¨å½“å‰æ±‡ç‡è®¡ç®—
          paymentAmount = cryptoAmount;
          paymentCurrency = 'USDT';
        }
      } else {
        // éªŒè¯é”å®šæ±‡ç‡æ˜¯å¦æœ‰æ•ˆ
        try {
          const lockInfo = await paymentApi.getExchangeRateLock(lockId);
          if (lockInfo.valid) {
            // ä½¿ç”¨é”å®šæ±‡ç‡è®¡ç®—ï¼Œç¡®ä¿ç²¾åº¦æ­£ç¡®
            paymentAmount = order.amount * lockInfo.rate;
            paymentCurrency = 'USDT';
            console.log('ä½¿ç”¨é”å®šæ±‡ç‡:', lockInfo.rate, 'åŸå§‹é‡‘é¢:', order.amount, 'æ”¯ä»˜é‡‘é¢:', paymentAmount);
          } else {
            // é”å®šå·²è¿‡æœŸï¼Œé‡æ–°é”å®š
            const lockResult = await paymentApi.lockExchangeRate({
              from: currency,
              to: 'USDT',
              amount: order.amount,
              expiresIn: 600,
            });
            lockId = lockResult.lockId;
            setExchangeRateLockId(lockId);
            paymentAmount = lockResult.cryptoAmount;
            paymentCurrency = 'USDT';
            console.log('æ±‡ç‡å·²é‡æ–°é”å®š:', lockId, 'æ”¯ä»˜é‡‘é¢:', paymentAmount);
          }
        } catch (error) {
          console.error('éªŒè¯é”å®šæ±‡ç‡å¤±è´¥:', error);
          // ä½¿ç”¨å½“å‰æ±‡ç‡è®¡ç®—
          paymentAmount = cryptoAmount || order.amount * (exchangeRate || 0.142);
          paymentCurrency = 'USDT';
        }
      }
    }

    const { address: tokenAddress, decimals: tokenDecimals } = await getTokenMetadata(paymentCurrency);
    const paymentAmountInSmallestUnit = ethers.parseUnits(
      paymentAmount.toFixed(tokenDecimals),
      tokenDecimals,
    );

    // 0. æ£€æŸ¥æˆæƒçŠ¶æ€ï¼ˆè¯Šæ–­ç”¨ï¼‰- åœ¨é‡‘é¢è®¡ç®—ä¹‹åè¿›è¡Œ
    try {
      const { checkAuthorizationStatus } = await import('@/utils/check-authorization-status');
      const authStatus = await checkAuthorizationStatus({
        paymentAmount: paymentAmountInSmallestUnit.toString(),
        tokenDecimals: tokenDecimals,
      });
      
      if (!authStatus.isAuthorized) {
        throw new Error('æœªæˆæƒUSDTç»™ERC8004åˆçº¦ï¼Œè¯·å…ˆåˆ›å»ºSession');
      }
      if (!authStatus.tokenAddressMatch) {
        throw new Error(`ä»£å¸åœ°å€ä¸åŒ¹é…ï¼šå‰ç«¯ä½¿ç”¨ ${authStatus.tokenAddress}ï¼Œä½†ERC8004åˆçº¦ä½¿ç”¨ ${authStatus.erc8004TokenAddress}`);
      }
      if (!authStatus.hasEnoughAllowance) {
        throw new Error(`æˆæƒé¢åº¦ä¸è¶³ï¼šå½“å‰æˆæƒ ${authStatus.currentAllowanceFormatted} USDTï¼Œéœ€è¦ ${ethers.formatUnits(paymentAmountInSmallestUnit, tokenDecimals)} USDT`);
      }
      console.log('âœ… æˆæƒçŠ¶æ€æ£€æŸ¥é€šè¿‡');
    } catch (authError: any) {
      if (authError.message && (authError.message.includes('æœªæˆæƒ') || authError.message.includes('é¢åº¦ä¸è¶³') || authError.message.includes('ä¸åŒ¹é…'))) {
        console.error('âŒ æˆæƒçŠ¶æ€æ£€æŸ¥å¤±è´¥:', authError.message);
        setError(authError.message);
        setStatus('error');
        return;
      }
      // å…¶ä»–é”™è¯¯ï¼ˆå¦‚æ¨¡å—åŠ è½½å¤±è´¥ï¼‰å¿½ç•¥ï¼Œç»§ç»­æ‰§è¡Œ
      console.warn('âš ï¸ æˆæƒçŠ¶æ€æ£€æŸ¥å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œ:', authError.message || authError);
    }

    // 2. ä½¿ç”¨ Session Key ç­¾åï¼ˆé“¾ä¸‹ï¼‰
    // æ³¨æ„ï¼šåˆçº¦æœŸæœ›çš„é‡‘é¢æ˜¯ 6 decimalsï¼ˆUSDCæ ‡å‡†ï¼‰ï¼Œå³ä½¿å®é™…æ”¯ä»˜ä½¿ç”¨ USDTï¼ˆ18 decimalsï¼‰
    // æ‰€ä»¥ç­¾åæ—¶ä¹Ÿéœ€è¦ä½¿ç”¨ 6 decimals çš„é‡‘é¢ï¼Œä¸åˆçº¦éªŒè¯ä¿æŒä¸€è‡´
    // âš ï¸ é‡è¦ï¼šç²¾åº¦è½¬æ¢é€»è¾‘å¿…é¡»ä¸åˆçº¦ä¿æŒä¸€è‡´ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ”¯ä»˜å¤±è´¥
    const contractDecimals = 6; // åˆçº¦æœŸæœ› 6 decimals
    let amountForSignature: bigint;
    if (tokenDecimals > contractDecimals) {
      // ä»é«˜ç²¾åº¦è½¬æ¢ä¸ºä½ç²¾åº¦ï¼ˆä¾‹å¦‚ï¼š18 -> 6ï¼Œé™¤ä»¥ 10^12ï¼‰
      // ä½¿ç”¨ ethers.parseUnits å’Œ formatUnits æ¥é¿å… bigint æŒ‡æ•°è¿ç®—é—®é¢˜
      const diff = tokenDecimals - contractDecimals;
      let scaleFactor = BigInt(1);
      for (let i = 0; i < diff; i++) {
        scaleFactor = scaleFactor * BigInt(10);
      }
      amountForSignature = paymentAmountInSmallestUnit / scaleFactor;
    } else if (tokenDecimals < contractDecimals) {
      // ä»ä½ç²¾åº¦è½¬æ¢ä¸ºé«˜ç²¾åº¦ï¼ˆä¾‹å¦‚ï¼š6 -> 18ï¼Œä¹˜ä»¥ 10^12ï¼‰
      const diff = contractDecimals - tokenDecimals;
      let scaleFactor = BigInt(1);
      for (let i = 0; i < diff; i++) {
        scaleFactor = scaleFactor * BigInt(10);
      }
      amountForSignature = paymentAmountInSmallestUnit * scaleFactor;
    } else {
      // ç²¾åº¦ç›¸åŒï¼Œç›´æ¥ä½¿ç”¨
      amountForSignature = paymentAmountInSmallestUnit;
    }

    // è·å– chainIdï¼Œç¡®ä¿ä¸åç«¯ä¸€è‡´ï¼ˆBSC Testnet = 97ï¼‰
    let chainId = 97; // é»˜è®¤ BSC Testnet
    try {
      if (window.ethereum) {
        const id = await window.ethereum.request({ method: 'eth_chainId' });
        const parsedId = parseInt(id as string, 16);
        // åªä½¿ç”¨ BSC Testnet (97)ï¼Œå¦‚æœç”¨æˆ·åœ¨å…¶ä»–ç½‘ç»œï¼Œä½¿ç”¨é»˜è®¤å€¼
        if (parsedId === 97) {
          chainId = parsedId;
        } else {
          console.warn(`âš ï¸ æ£€æµ‹åˆ°ç½‘ç»œ chainId=${parsedId}ï¼Œä½†ç³»ç»ŸæœŸæœ› BSC Testnet (97)ï¼Œä½¿ç”¨é»˜è®¤å€¼ 97`);
        }
      }
    } catch (error) {
      console.warn('è·å– chainId å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼ 97 (BSC Testnet):', error);
    }
    
    // ä¿®å¤bytes32é”™è¯¯ï¼šorder.idå¯èƒ½æ˜¯UUIDï¼Œè¶…è¿‡32å­—èŠ‚ï¼Œä½¿ç”¨hash
    // ä¸åç«¯ä¿æŒä¸€è‡´ï¼šç›´æ¥ä½¿ç”¨ keccak256(toUtf8Bytes(order.id))ï¼Œä¸éœ€è¦ slice
    const orderIdBytes32 = ethers.keccak256(ethers.toUtf8Bytes(order.id)) as `0x${string}`;
    
    // è·å–æ”¶æ¬¾åœ°å€ï¼šåº”è¯¥ä½¿ç”¨ Commission åˆçº¦åœ°å€ï¼ˆèµ„é‡‘å…ˆè½¬åˆ°åˆçº¦åšåˆ†æ¶¦ï¼‰
    // ä»åç«¯è·å– Commission åˆçº¦åœ°å€ï¼Œç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„åœ°å€
    let recipientAddress = order.to;
    if (!recipientAddress) {
      try {
        const contractInfo = await paymentApi.getContractAddress();
        recipientAddress = contractInfo.commissionContractAddress;
        if (!recipientAddress) {
          throw new Error('Commissionåˆçº¦åœ°å€æœªé…ç½®');
        }
      } catch (error) {
        console.error('è·å–Commissionåˆçº¦åœ°å€å¤±è´¥:', error);
        throw new Error('æ— æ³•è·å–æ”¶æ¬¾åœ°å€ï¼Œè¯·ç¨åé‡è¯•');
      }
    }
    
    // ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„ sessionIdï¼ˆå¿…é¡»æ˜¯ bytes32 æ ¼å¼ï¼‰
    // session.sessionId æ˜¯é“¾ä¸Šçš„ bytes32ï¼Œsession.id æ˜¯æ•°æ®åº“ UUIDï¼Œä¸èƒ½æ··ç”¨
    if (!session.sessionId) {
      throw new Error('Session ID æ— æ•ˆï¼šç¼ºå°‘é“¾ä¸Š sessionIdï¼Œè¯·é‡æ–°åˆ›å»º Session');
    }
    const sessionIdBytes32 = session.sessionId as `0x${string}`;
    
    // åˆçº¦ä½¿ç”¨ abi.encodePacked æ„å»º messageHashï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ solidityPackedKeccak256 æ¥åŒ¹é…
    // åˆçº¦é€»è¾‘ï¼škeccak256(abi.encodePacked(sessionId, to, amount, paymentId, chainId))
    const innerHash = ethers.solidityPackedKeccak256(
      ['bytes32', 'address', 'uint256', 'bytes32', 'uint256'],
      [
        sessionIdBytes32, // ä½¿ç”¨é“¾ä¸Šçš„ bytes32 sessionId
        recipientAddress, // ä½¿ç”¨ Commission åˆçº¦åœ°å€æˆ–è®¢å•æŒ‡å®šçš„åœ°å€
        amountForSignature, // ä½¿ç”¨è½¬æ¢åçš„é‡‘é¢ï¼ˆ6 decimalsï¼Œä¸åˆçº¦ä¸€è‡´ï¼‰
        orderIdBytes32, // ä½¿ç”¨hashåçš„orderId
        chainId,
      ],
    );
    
    // åˆçº¦æ·»åŠ  EIP-191 å‰ç¼€çš„æ–¹å¼ï¼škeccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", innerHash))
    // ä¼ é€’ innerHash ç»™ signWithSessionKeyï¼Œè®©å®ƒä½¿ç”¨ solidityPackedKeccak256 æ·»åŠ å‰ç¼€ï¼ˆä¸åˆçº¦ä¸€è‡´ï¼‰
    console.log('Inner hash:', innerHash);
    console.log('Session signer:', session.signer);
    console.log('Payment amount:', paymentAmount, paymentCurrency);
    console.log('ğŸ” ç­¾åå‚æ•°è°ƒè¯•:', {
      sessionIdBytes32,
      recipientAddress,
      amountForSignature: amountForSignature.toString(),
      orderIdBytes32,
      chainId: chainId.toString(),
      orderId: order.id,
    });

    const signature = await SessionKeyManager.signWithSessionKey(
      session.signer,
      innerHash, // ä¼ é€’ innerHashï¼Œè®© signWithSessionKey ä½¿ç”¨ solidityPackedKeccak256 æ·»åŠ  EIP-191 å‰ç¼€
    );

    console.log('Signature generated:', signature);

    // 3. è°ƒç”¨æ”¯ä»˜ APIï¼ˆä½¿ç”¨ x402 paymentMethodï¼‰
    // æ³¨æ„ï¼šåç«¯ä¼šè‡ªåŠ¨è°ƒç”¨relayeræ‰§è¡Œæ”¯ä»˜
    console.log('ğŸš€ å¼€å§‹æ‰§è¡Œ QuickPay æ”¯ä»˜è¯·æ±‚...', {
      amount: paymentAmount,
      currency: paymentCurrency,
      sessionId: session.sessionId,
      signer: session.signer,
      amountInSmallestUnit: paymentAmountInSmallestUnit.toString(),
      tokenAddress,
      tokenDecimals,
    });
    
    try {
      const paymentRequest = {
        amount: paymentAmount, // ä½¿ç”¨è½¬æ¢åçš„é‡‘é¢
        currency: paymentCurrency, // ä½¿ç”¨è½¬æ¢åçš„è´§å¸
        paymentMethod: 'x402', // QuickPay ä½¿ç”¨ x402
        merchantId: order.merchantId,
        description: order.description,
        metadata: {
          sessionId: session.sessionId, // åªä¼ é€’é“¾ä¸Šçš„ bytes32 sessionId
          signature,
          nonce: Date.now(),
          to: recipientAddress, // ä½¿ç”¨ Commission åˆçº¦åœ°å€æˆ–è®¢å•æŒ‡å®šçš„åœ°å€
          tokenAddress,
          tokenDecimals,
          amountInSmallestUnit: paymentAmountInSmallestUnit.toString(), // ä¼ é€’æœ€å°å•ä½çš„é‡‘é¢
          orderId: order.id, // ä¼ é€’è®¢å•IDï¼Œç”¨äºç­¾åéªŒè¯
          // æ±‡ç‡ç›¸å…³ä¿¡æ¯
          ...(isFiatCurrency && exchangeRate && {
            exchangeRateLockId: lockId,
            originalAmount: order.amount,
            originalCurrency: currency,
            exchangeRate: exchangeRate,
            conversionType: 'fiat_to_crypto',
          }),
        },
      };
      
      console.log('ğŸ“¤ å‘é€ QuickPay æ”¯ä»˜è¯·æ±‚åˆ°åç«¯...', paymentRequest);
      
      const result = await paymentApi.process(paymentRequest);

      console.log('ğŸ’° æ”¯ä»˜å“åº”:', result);
      console.log('ğŸ’° æ”¯ä»˜è¯¦æƒ…:', {
        paymentId: result.id,
        status: result.status,
        transactionHash: result.transactionHash,
        amount: result.amount,
        currency: result.currency,
      });

      // æ£€æŸ¥æ”¯ä»˜çŠ¶æ€
      if (result.status === 'failed' || result.status === 'cancelled') {
        const errorMessage = result.metadata?.relayerError || result.metadata?.errorDetails?.message || 'æ”¯ä»˜å¤±è´¥';
        console.error('âŒ QuickPay æ”¯ä»˜å¤±è´¥:', errorMessage);
        setError(errorMessage);
        setStatus('error');
        return;
      }

      if (result.status === 'completed' || result.status === 'processing') {
        console.log('âœ… QuickPay æ”¯ä»˜æˆåŠŸ');
        setStatus('success');
        if (onSuccess) {
          onSuccess(result);
        }
      } else {
        console.warn('âš ï¸ QuickPay æ”¯ä»˜çŠ¶æ€æœªçŸ¥:', result.status);
        setStatus('success'); // æš‚æ—¶æ ‡è®°ä¸ºæˆåŠŸï¼Œç­‰å¾…åç»­ç¡®è®¤
        if (onSuccess) {
          onSuccess(result);
        }
      }
    } catch (error: any) {
      console.error('âŒ QuickPay API é”™è¯¯:', error);
      console.error('é”™è¯¯è¯¦æƒ…:', {
        message: error.message,
        stack: error.stack,
        response: error.response,
      });
      // å¦‚æœ x402 æ”¯ä»˜å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ relayer API
      try {
        const result = await paymentApi.relayerQuickPay({
          sessionId: session.sessionId, // åªä½¿ç”¨é“¾ä¸Šçš„ bytes32 sessionId
          paymentId: order.id,
          to: order.to || '0x0000000000000000000000000000000000000000',
          amount: paymentAmountInSmallestUnit.toString(),
          signature,
          nonce: Date.now(),
        });
        
        if (result.success) {
          setStatus('success');
          if (onSuccess) {
            onSuccess(result);
          }
        } else {
          throw new Error('QuickPay æ”¯ä»˜å¤±è´¥');
        }
      } catch (relayerError: any) {
        throw new Error(relayerError.message || 'QuickPay æ”¯ä»˜å¤±è´¥');
      }
    }
  };

  const handleProviderPay = async (
    provider?: 'google' | 'apple' | 'card' | 'local' | 'transak',
    option?: ProviderOption,
  ) => {
    const providerFallback = preflightResult?.providerOptions?.find(
      (opt) => opt.id === provider,
    );
    const resolvedOption = option || providerFallback || preflightResult?.providerOptions?.[0] || null;

    if (resolvedOption) {
      setSelectedProviderOption(resolvedOption);
    }

    providerModalAutoOpened.current = true;
    setShowProviderModal(true);
  };

  const handleWalletPay = async () => {
    if (!isConnected || !defaultWallet) {
      setError('è¯·å…ˆè¿æ¥é’±åŒ…ã€‚ç‚¹å‡»å³ä¸Šè§’ç”¨æˆ·èœå•ä¸­çš„"è¿æ¥é’±åŒ…"é€‰é¡¹ã€‚');
      setStatus('error');
      return;
    }

    if (!window.ethereum) {
      setError('æœªæ£€æµ‹åˆ°é’±åŒ…ï¼Œè¯·å®‰è£… MetaMask æˆ–å…¶ä»–é’±åŒ…');
      setStatus('error');
      return;
    }

    try {
      setStatus('processing');
      setError(null);

      // å¦‚æœå·²ç»è¿æ¥äº†é’±åŒ…ï¼Œç›´æ¥ä½¿ç”¨å·²è¿æ¥çš„é’±åŒ…åœ°å€ï¼Œé¿å…è§¦å‘ MetaMask å¼¹çª—
      let from: string;
      if (defaultWallet && defaultWallet.address) {
        from = defaultWallet.address;
        console.log('âœ… ä½¿ç”¨å·²è¿æ¥çš„é’±åŒ…åœ°å€:', from);
      } else {
        // åªæœ‰åœ¨æœªè¿æ¥æ—¶æ‰è¯·æ±‚è´¦æˆ·ï¼ˆä¼šè§¦å‘å¼¹çª—ï¼‰
        const accounts: string[] = await window.ethereum.request({ method: 'eth_requestAccounts' });
        from = accounts?.[0];
        if (!from) {
          throw new Error('æœªè·å–åˆ°é’±åŒ…åœ°å€ï¼Œè¯·é‡è¯•');
        }
      }

      const currency = order.currency || 'USDC';
      const isFiatCurrency = ['CNY', 'USD', 'EUR', 'GBP', 'JPY'].includes(currency.toUpperCase());
      const merchantConfig = order.metadata?.merchantPaymentConfig || 'both';
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦æ±‡ç‡è½¬æ¢ï¼ˆå•†å®¶æŒ‚æ³•å¸ï¼Œç”¨æˆ·ç”¨æ•°å­—è´§å¸æ”¯ä»˜ï¼‰
      let paymentAmount = order.amount;
      let paymentCurrency = currency;
      let lockId = exchangeRateLockId;
      
      if (isFiatCurrency) {
        // å¦‚æœå•†å®¶åªæ¥å—æ³•å¸ï¼Œä¸å…è®¸ç”¨é’±åŒ…æ”¯ä»˜
        if (merchantConfig === 'fiat_only') {
          setError(`${currency} æ˜¯æ³•å¸ï¼Œå•†å®¶åªæ¥å—æ³•å¸ï¼Œè¯·ä½¿ç”¨ Provider æ”¯ä»˜æ–¹å¼ï¼ˆé“¶è¡Œå¡/Google Pay/Apple Payï¼‰`);
          setStatus('error');
          return;
        }
        
        // å¦‚æœå•†å®¶æ¥å—æ•°å­—è´§å¸ï¼Œéœ€è¦æ±‡ç‡è½¬æ¢
        if (exchangeRate && cryptoAmount) {
          // å¦‚æœè¿˜æ²¡æœ‰é”å®šæ±‡ç‡ï¼Œå…ˆé”å®š
          if (!lockId) {
            try {
              const lockResult = await paymentApi.lockExchangeRate({
                from: currency,
                to: 'USDT',
                amount: order.amount,
                expiresIn: 600, // 10åˆ†é’Ÿ
              });
              lockId = lockResult.lockId;
              setExchangeRateLockId(lockId);
              paymentAmount = lockResult.cryptoAmount;
              paymentCurrency = 'USDT';
              console.log('æ±‡ç‡å·²é”å®š:', lockId, 'æ”¯ä»˜é‡‘é¢:', paymentAmount, paymentCurrency);
            } catch (error) {
              console.error('é”å®šæ±‡ç‡å¤±è´¥:', error);
              // å¦‚æœé”å®šå¤±è´¥ï¼Œä½¿ç”¨å½“å‰æ±‡ç‡è®¡ç®—
              paymentAmount = cryptoAmount;
              paymentCurrency = 'USDT';
            }
          } else {
            // éªŒè¯é”å®šæ±‡ç‡æ˜¯å¦æœ‰æ•ˆ
            try {
              const lockInfo = await paymentApi.getExchangeRateLock(lockId);
              if (lockInfo.valid) {
                paymentAmount = order.amount * lockInfo.rate;
                paymentCurrency = 'USDT';
                console.log('ä½¿ç”¨é”å®šæ±‡ç‡:', lockInfo.rate, 'æ”¯ä»˜é‡‘é¢:', paymentAmount);
              } else {
                // é”å®šå·²è¿‡æœŸï¼Œé‡æ–°é”å®š
                const lockResult = await paymentApi.lockExchangeRate({
                  from: currency,
                  to: 'USDT',
                  amount: order.amount,
                  expiresIn: 600,
                });
                lockId = lockResult.lockId;
                setExchangeRateLockId(lockId);
                paymentAmount = lockResult.cryptoAmount;
                paymentCurrency = 'USDT';
                console.log('æ±‡ç‡å·²é‡æ–°é”å®š:', lockId, 'æ”¯ä»˜é‡‘é¢:', paymentAmount);
              }
            } catch (error) {
              console.error('éªŒè¯é”å®šæ±‡ç‡å¤±è´¥:', error);
              // ä½¿ç”¨å½“å‰æ±‡ç‡è®¡ç®—
              paymentAmount = cryptoAmount || order.amount * (exchangeRate || 0.142);
              paymentCurrency = 'USDT';
            }
          }
        } else {
          // æ²¡æœ‰æ±‡ç‡ä¿¡æ¯ï¼Œä¸å…è®¸æ”¯ä»˜
          setError(`æ— æ³•è·å– ${currency} åˆ° USDT çš„æ±‡ç‡ï¼Œè¯·ç¨åé‡è¯•`);
          setStatus('error');
          return;
        }
      }

      // Walletæ”¯ä»˜ä¹Ÿåº”è¯¥è½¬åˆ°Commissionåˆçº¦ï¼Œç”±åˆçº¦åšåˆ†æ¶¦åå†è½¬åˆ°å•†æˆ·
      let to: string;
      if (order.to) {
        // å¦‚æœè®¢å•æŒ‡å®šäº†æ”¶æ¬¾åœ°å€ï¼Œä½¿ç”¨è®¢å•åœ°å€
        to = order.to;
      } else {
        // å¦åˆ™ä»åç«¯è·å–Commissionåˆçº¦åœ°å€
        try {
          const contractAddresses = await paymentApi.getContractAddress();
          to = contractAddresses.commissionContractAddress;
          if (!to) {
            throw new Error('æ— æ³•è·å–Commissionåˆçº¦åœ°å€');
          }
        } catch (error) {
          console.error('è·å–Commissionåˆçº¦åœ°å€å¤±è´¥:', error);
          setError('æ— æ³•è·å–æ”¶æ¬¾åœ°å€ï¼Œè¯·ç¨åé‡è¯•');
          setStatus('error');
          return;
        }
      }
      
      const { address: tokenAddress, decimals } = await getTokenMetadata(paymentCurrency);
      
      // åˆ›å»º provider å’Œ signer
      // å¦‚æœå·²ç»è¿æ¥äº†é’±åŒ…ï¼Œä½¿ç”¨å·²è¿æ¥çš„é’±åŒ…åœ°å€ï¼Œé¿å…è§¦å‘ MetaMask å¼¹çª—
      const provider = new ethers.BrowserProvider(window.ethereum);
      let signer: ethers.Signer;
      try {
        // å…ˆå°è¯•è·å–å·²æˆæƒçš„è´¦æˆ·ï¼ˆä¸ä¼šå¼¹çª—ï¼‰
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts && accounts.length > 0) {
          // ä½¿ç”¨å·²æˆæƒçš„è´¦æˆ·åˆ›å»º signer
          signer = await provider.getSigner();
          console.log('âœ… ä½¿ç”¨å·²æˆæƒçš„è´¦æˆ·è¿›è¡Œé’±åŒ…æ”¯ä»˜:', accounts[0]);
        } else {
          // åªæœ‰åœ¨æœªæˆæƒæ—¶æ‰è°ƒç”¨ getSignerï¼ˆå¯èƒ½ä¼šå¼¹çª—ï¼‰
          signer = await provider.getSigner();
        }
      } catch (error) {
        // å¦‚æœè·å–å¤±è´¥ï¼Œå›é€€åˆ° getSigner
        signer = await provider.getSigner();
      }
      const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      
      // è½¬æ¢é‡‘é¢ï¼Œç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„ç²¾åº¦
      // é‡è¦ï¼šä½¿ç”¨toFixedç¡®ä¿ç²¾åº¦æ­£ç¡®ï¼Œé¿å…æµ®ç‚¹æ•°é—®é¢˜
      // ä½¿ç”¨è½¬æ¢åçš„é‡‘é¢ï¼ˆå¦‚æœå·²è½¬æ¢ï¼‰
      const amountString = paymentAmount.toFixed(decimals);
      const amountInWei = ethers.parseUnits(amountString, decimals);
      
      console.log('Amount conversion:', {
        original: order.amount,
        converted: paymentAmount,
        currency: paymentCurrency,
        fixed: amountString,
        decimals,
        amountInWei: amountInWei.toString(),
      });

      console.log('Transferring USDT:', {
        from,
        to,
        amount: paymentAmount,
        currency: paymentCurrency,
        amountInWei: amountInWei.toString(),
      });

      // è°ƒç”¨ USDT transfer å‡½æ•°
      const tx = await tokenContract.transfer(to, amountInWei);
      console.log('Transaction sent:', tx.hash);

      // ç­‰å¾…äº¤æ˜“ç¡®è®¤
      const receipt = await tx.wait();
      console.log('Transaction confirmed:', receipt);

      // è°ƒç”¨åç«¯APIè®°å½•æ”¯ä»˜ï¼ˆå¦‚æœå¤±è´¥ï¼Œä¸å½±å“æˆåŠŸçŠ¶æ€ï¼Œå› ä¸ºé“¾ä¸Šè½¬è´¦å·²æˆåŠŸï¼‰
      try {
        const result = await paymentApi.process({
          amount: paymentAmount, // ä½¿ç”¨è½¬æ¢åçš„é‡‘é¢
          currency: paymentCurrency, // ä½¿ç”¨è½¬æ¢åçš„è´§å¸
          paymentMethod: 'wallet',
          merchantId: order.merchantId,
          description: order.description,
          metadata: {
            orderId: order.id,
            to: order.to,
            txHash: receipt.hash,
              tokenDecimals: decimals,
            txParams: {
              from,
              to,
              amount: paymentAmount,
              currency: paymentCurrency,
                tokenAddress,
            },
            // æ±‡ç‡ç›¸å…³ä¿¡æ¯
            ...(isFiatCurrency && exchangeRate && {
              exchangeRateLockId: lockId,
              originalAmount: order.amount,
              originalCurrency: currency,
              exchangeRate: exchangeRate,
              conversionType: 'fiat_to_crypto',
            }),
          },
        });

        // æ”¯ä»˜æˆåŠŸåï¼Œæ£€æŸ¥é’±åŒ…ä½™é¢å˜åŒ–ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        if (window.ethereum) {
          try {
            const provider = new ethers.BrowserProvider(window.ethereum);
            // ä½¿ç”¨å·²æˆæƒçš„è´¦æˆ·ï¼Œé¿å…è§¦å‘å¼¹çª—
            let userAddress: string;
            try {
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              if (accounts && accounts.length > 0) {
                userAddress = accounts[0];
              } else {
                const signer = await provider.getSigner();
                userAddress = await signer.getAddress();
              }
            } catch {
              const signer = await provider.getSigner();
              userAddress = await signer.getAddress();
            }
            const tokenContract = new ethers.Contract(
              tokenAddress,
              ['function balanceOf(address) view returns (uint256)'],
              provider,
            );
            const balanceAfter = await tokenContract.balanceOf(userAddress);
            console.log('ğŸ’° æ”¯ä»˜åé’±åŒ…ä½™é¢:', ethers.formatUnits(balanceAfter, decimals), paymentCurrency);
          } catch (balanceError) {
            console.warn('æ— æ³•æŸ¥è¯¢æ”¯ä»˜åä½™é¢:', balanceError);
          }
        }

        setStatus('success');
        if (onSuccess) {
          onSuccess(result);
        }
      } catch (apiError: any) {
        // åç«¯APIè°ƒç”¨å¤±è´¥ï¼Œä½†é“¾ä¸Šè½¬è´¦å·²æˆåŠŸï¼Œä»ç„¶æ˜¾ç¤ºæˆåŠŸ
        console.warn('Backend API call failed, but on-chain transfer succeeded:', apiError);
        console.warn('Transaction hash:', receipt.hash);
        
        // æ˜¾ç¤ºæˆåŠŸï¼Œä½†æç¤ºåç«¯è®°å½•å¯èƒ½å¤±è´¥
        setStatus('success');
        if (onSuccess) {
          onSuccess({
            id: order.id,
            status: 'completed',
            transactionHash: receipt.hash,
            message: 'é“¾ä¸Šè½¬è´¦æˆåŠŸï¼Œä½†åç«¯è®°å½•å¯èƒ½å¤±è´¥ï¼Œè¯·ç¨åæŸ¥çœ‹è®¢å•çŠ¶æ€',
          });
        }
      }
    } catch (error: any) {
      console.error('Wallet payment error:', error);
      console.error('Error response:', error.response);
      console.error('Error data:', error.response?.data);
      
      // åªæœ‰åœ¨é“¾ä¸Šè½¬è´¦å¤±è´¥æ—¶æ‰æ˜¾ç¤ºé”™è¯¯
      if (error.code === 4001 || error.message?.includes('cancel') || error.message?.includes('User denied')) {
        setError('ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“');
        setStatus('error');
      } else if (
        error.message?.includes('insufficient funds') || 
        error.message?.includes('ä½™é¢ä¸è¶³') ||
        error.message?.includes('exceeds balance') ||
        error.message?.includes('BEP40') ||
        error.reason?.includes('exceeds balance') ||
        error.data?.message?.includes('exceeds balance')
      ) {
        setError('USDTä½™é¢ä¸è¶³ï¼Œè¯·ç¡®ä¿é’±åŒ…ä¸­æœ‰è¶³å¤Ÿçš„æµ‹è¯•USDT');
        setStatus('error');
      } else if (error.message?.includes('replacement') || error.message?.includes('nonce')) {
        setError('äº¤æ˜“nonceå†²çªï¼Œè¯·ç¨åé‡è¯•');
        setStatus('error');
      } else {
        // å…¶ä»–é”™è¯¯ï¼ˆå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜ç­‰ï¼‰
        const errorMsg = error.reason || error.message || error.data?.message || 'é’±åŒ…æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•';
        setError(errorMsg);
        setStatus('error');
      }
    }
  };

  // åœºæ™¯1: QuickPay (Session æœ‰æ•ˆ + ä½™é¢å……è¶³)
  const QuickPayView = () => {
    const session = currentSession || activeSession;
    const needsFxConversion = isFiatOrderCurrency && merchantAllowsCrypto;
    const fxReady =
      !needsFxConversion || (!!exchangeRate && !!cryptoAmount && !isLoadingExchangeRate);
    if (!session) {
      return (
        <div className="animate-fade-in">
          <div className="bg-indigo-50 border border-indigo-200 rounded-xl p-4 mb-6">
            <div className="flex items-center gap-3 mb-3">
              <Zap className="text-indigo-600" size={20} />
              <div>
                <div className="text-sm font-medium text-indigo-900">å¯ç”¨ QuickPay</div>
                <div className="text-xs text-indigo-600">åˆ›å»º Session åå³å¯äº«å—å¿«é€Ÿæ”¯ä»˜</div>
              </div>
            </div>
            <button
              onClick={() => setShowSessionManager(true)}
              className="w-full bg-indigo-600 text-white py-2 rounded-lg text-sm font-medium hover:bg-indigo-700 transition-colors"
            >
              å¼€å¯å…å¯†é¢åº¦
            </button>
          </div>
          <div className="text-center text-xs text-slate-500 mb-4">
            æˆ–ä½¿ç”¨å…¶ä»–æ”¯ä»˜æ–¹å¼
          </div>
        </div>
      );
    }

    return (
    <div className="animate-fade-in">
      <div className="bg-indigo-50/50 border border-indigo-100 rounded-xl p-4 mb-6">
        <div className="flex justify-between items-center mb-2">
          <span className="text-xs font-bold text-indigo-600 uppercase tracking-wider">
              âš¡ QuickPay æ¨è
          </span>
          <span className="text-xs text-indigo-400">Gasless â€¢ Instant</span>
        </div>
        <div className="flex items-center gap-3">
          <div className="p-2 bg-white rounded-lg shadow-sm text-indigo-600">
              <Zap size={20} />
          </div>
          <div>
              <div className="text-sm font-medium text-slate-700">QuickPay å…å¯†é¢åº¦å·²å¯ç”¨</div>
              <div className="text-xs text-slate-500">ä»æ‚¨çš„å…å¯†æˆæƒé¢åº¦ç›´æ¥åˆ’æ‰£</div>
          </div>
        </div>
        {preflightResult?.sessionLimit && (
          <div className="mt-3 pt-3 border-t border-indigo-100">
            <div className="text-xs text-slate-600">
              ä»Šæ—¥å‰©ä½™é¢åº¦: ${preflightResult.sessionLimit.dailyRemaining} USDC
            </div>
          </div>
        )}
      </div>

      <button
          type="button"
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('ğŸ”µ QuickPay Pay button clicked');
            handlePay();
          }}
          disabled={status === 'processing' || !session || !fxReady}
        className="group relative w-full bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white py-4 rounded-2xl font-bold text-lg shadow-lg shadow-indigo-500/30 transition-all active:scale-[0.98] flex items-center justify-center gap-2 overflow-hidden disabled:opacity-50 disabled:cursor-not-allowed"
      >
        <div className="absolute inset-0 bg-white/20 group-hover:translate-x-full transition-transform duration-700 skew-x-12 -translate-x-full"></div>
        {status === 'processing' ? (
          <>
            <Loader2 className="animate-spin" size={20} />
            <span>Processing...</span>
          </>
        ) : (
          <>
            <Zap className="fill-current" size={20} />
            <span>ä¸€é”®æ”¯ä»˜ {(() => {
              const currency = order.currency || 'USDC';
              const symbol = currency === 'CNY' ? 'Â¥' : currency === 'USD' ? '$' : currency === 'EUR' ? 'â‚¬' : currency === 'GBP' ? 'Â£' : currency === 'JPY' ? 'Â¥' : '$';
              return `${symbol}${order.amount.toFixed(currency === 'JPY' ? 0 : 2)}`;
            })()}</span>
          </>
        )}
      </button>

      {needsFxConversion && !fxReady && (
        <div className="text-center mt-2 text-xs text-amber-600">
          æ­£åœ¨è·å–å®æ—¶æ±‡ç‡ï¼Œè¯·ç¨å€™â€¦
        </div>
      )}

      <div className="text-center mt-4 text-xs text-slate-400 flex items-center justify-center gap-1">
        <ShieldCheck size={12} />
        <span>Agentrix Relayer å®‰å…¨å®ˆæŠ¤</span>
      </div>
    </div>
  );
  };

  // åœºæ™¯2: Provider (Transak) - æ³•å¸æ”¯ä»˜é€šé“
  // å½“è·¯ç”±ä¸º provider æ—¶ï¼Œè‡ªåŠ¨æ‰“å¼€ Transak Widget
  useEffect(() => {
    if (routeType === 'provider' && status === 'ready' && !providerModalAutoOpened.current) {
      providerModalAutoOpened.current = true;
      setShowProviderModal(true);
    }
  }, [routeType, status]);

  // åœºæ™¯3: Wallet Pay
  const WalletView = () => {
    if (!isConnected) {
      return (
        <div className="animate-fade-in">
          <div className="bg-yellow-50 border border-yellow-200 rounded-xl p-4 mb-6">
            <div className="flex items-center gap-3 mb-3">
              <Wallet className="text-yellow-600" size={20} />
              <div>
                <div className="text-sm font-medium text-yellow-900">æœªè¿æ¥é’±åŒ…</div>
                <div className="text-xs text-yellow-700">è¯·å…ˆè¿æ¥é’±åŒ…ä»¥ä½¿ç”¨é’±åŒ…æ”¯ä»˜</div>
              </div>
            </div>
            <button
              onClick={async () => {
                try {
                  setStatus('loading');
                  setError(null);
                  // å°è¯•è¿æ¥MetaMaskï¼ˆæœ€å¸¸è§çš„é’±åŒ…ï¼‰
                  // æ£€æŸ¥ window.ethereum æ˜¯å¦å­˜åœ¨ï¼ˆMetaMask æˆ–å…¶ä»–æ³¨å…¥å¼é’±åŒ…ï¼‰
                  if (window.ethereum) {
                    // å¦‚æœ window.ethereum å­˜åœ¨ï¼Œå°è¯•è¿æ¥
                    // ä½¿ç”¨ç±»å‹æ–­è¨€ï¼Œå› ä¸º connect å‡½æ•°å¯èƒ½æ¥å—æ›´å¤šç±»å‹
                    try {
                      await connect('metamask' as any);
                      setStatus('ready');
                    } catch (connectError) {
                      // å¦‚æœ metamask è¿æ¥å¤±è´¥ï¼Œå°è¯•æŸ¥æ‰¾å…¶ä»–å¯ç”¨çš„è¿æ¥å™¨
                      const availableConnector = connectors.find(c => c.isInstalled);
                      if (availableConnector) {
                        await connect(availableConnector.id as any);
                        setStatus('ready');
                      } else {
                        setError('è¯·å…ˆå®‰è£…MetaMaské’±åŒ…ï¼Œæˆ–ç‚¹å‡»å³ä¸Šè§’ç”¨æˆ·èœå•ä¸­çš„"è¿æ¥é’±åŒ…"é€‰é¡¹ã€‚');
                        setStatus('ready');
                      }
                    }
                  } else {
                    // å¦‚æœæ²¡æœ‰ window.ethereumï¼Œå°è¯•ä½¿ç”¨å¯ç”¨çš„è¿æ¥å™¨
                    const availableConnector = connectors.find(c => c.isInstalled);
                    if (availableConnector) {
                      await connect(availableConnector.id as any);
                      setStatus('ready');
                    } else {
                      setError('è¯·å…ˆå®‰è£…MetaMaské’±åŒ…ï¼Œæˆ–ç‚¹å‡»å³ä¸Šè§’ç”¨æˆ·èœå•ä¸­çš„"è¿æ¥é’±åŒ…"é€‰é¡¹ã€‚');
                      setStatus('ready');
                    }
                  }
                } catch (error: any) {
                  console.error('é’±åŒ…è¿æ¥å¤±è´¥:', error);
                  setError(error.message || 'é’±åŒ…è¿æ¥å¤±è´¥ï¼Œè¯·é‡è¯•æˆ–ç‚¹å‡»å³ä¸Šè§’ç”¨æˆ·èœå•ä¸­çš„"è¿æ¥é’±åŒ…"é€‰é¡¹ã€‚');
                  setStatus('ready');
                }
              }}
              className="w-full bg-yellow-600 text-white py-2 rounded-lg text-sm font-medium hover:bg-yellow-700 transition-colors"
            >
              è¿æ¥é’±åŒ…
            </button>
          </div>
          <div className="text-center text-xs text-slate-500 mb-4">
            æˆ–ä½¿ç”¨å…¶ä»–æ”¯ä»˜æ–¹å¼
          </div>
        </div>
      );
    }

    const needsFxConversion = isFiatOrderCurrency && merchantAllowsCrypto;
    const walletFxReady =
      !needsFxConversion || (!!exchangeRate && !!cryptoAmount && !isLoadingExchangeRate);

    return (
    <div className="animate-fade-in">
      <div className="bg-white border border-slate-200 rounded-xl p-4 mb-4 shadow-sm">
        <div className="flex items-center gap-3 mb-4">
          <div className="p-2 bg-slate-100 rounded-lg">
            <Wallet size={20} className="text-slate-600" />
          </div>
          <div>
              <div className="text-sm font-medium text-slate-700">é’±åŒ…æ”¯ä»˜</div>
            <div className="text-xs text-slate-500">éœ€è¦é’±åŒ…ç¡®è®¤</div>
          </div>
        </div>
          {defaultWallet && (
            <div className="text-xs text-slate-500 mb-2">
              å½“å‰é’±åŒ…: {defaultWallet.address.slice(0, 6)}...{defaultWallet.address.slice(-4)}
            </div>
          )}
          {preflightResult?.walletBalanceIsMock ? (
            <div className="text-xs text-yellow-600">
              âš ï¸ æ— æ³•è·å–çœŸå®é’±åŒ…ä½™é¢ï¼Œè¯·ç¡®ä¿é’±åŒ…å·²è¿æ¥ä¸”ç½‘ç»œæ­£å¸¸
            </div>
          ) : preflightResult?.walletBalance ? (
            (() => {
              const balance = parseFloat(preflightResult.walletBalance);
              if (balance === 0) {
                return (
                  <div className="text-xs text-yellow-600">
                    âš ï¸ é’±åŒ…ä½™é¢ä¸º 0ï¼Œè¯·å…ˆå……å€¼
                  </div>
                );
              }
              return (
                <div className="text-xs text-slate-600">
                  é’±åŒ…ä½™é¢: ${balance.toFixed(2)} USDC
                </div>
              );
            })()
          ) : (
            <div className="text-xs text-yellow-600">
              âš ï¸ æ— æ³•è·å–é’±åŒ…ä½™é¢ï¼Œä½™é¢å¯èƒ½ä¸º 0 æˆ–é’±åŒ…æœªæ­£ç¡®ç»‘å®š
          </div>
        )}
      </div>

      <button
          type="button"
          onClick={async (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('ğŸ”µ Wallet Pay button clicked', {
              status,
              routeType,
              walletFxReady,
              isConnected,
              hasWallet: !!defaultWallet,
              isFiatOrderCurrency,
            });
            
            // ç¡®ä¿ä½¿ç”¨é’±åŒ…æ”¯ä»˜
            if (routeType !== 'wallet') {
              console.warn('âš ï¸ RouteType is not wallet, forcing wallet payment');
              setRouteType('wallet');
              // ç­‰å¾…çŠ¶æ€æ›´æ–°
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // ç›´æ¥è°ƒç”¨é’±åŒ…æ”¯ä»˜ï¼Œä¸é€šè¿‡handlePayè·¯ç”±
            try {
              await handleWalletPay();
            } catch (error) {
              console.error('Wallet payment error:', error);
            }
          }}
        disabled={status === 'processing' || (!walletFxReady && isFiatOrderCurrency) || !isConnected}
        className="w-full bg-slate-900 text-white py-4 rounded-2xl font-bold text-lg shadow-lg transition-all hover:bg-slate-800 flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {status === 'processing' ? (
          <>
            <Loader2 className="animate-spin" size={20} />
              <span>ç­‰å¾…é’±åŒ…ç¡®è®¤...</span>
          </>
        ) : (
          <>
            <Wallet size={20} />
            <span>Pay {(() => {
              const currency = order.currency || 'USDC';
              const symbol = currency === 'CNY' ? 'Â¥' : currency === 'USD' ? '$' : currency === 'EUR' ? 'â‚¬' : currency === 'GBP' ? 'Â£' : currency === 'JPY' ? 'Â¥' : '$';
              return `${symbol}${order.amount.toFixed(currency === 'JPY' ? 0 : 2)}`;
            })()}</span>
          </>
        )}
      </button>
      {needsFxConversion && !walletFxReady && (
        <div className="text-center mt-2 text-xs text-amber-600">
          æ­£åœ¨å‡†å¤‡æ±‡ç‡ä¿¡æ¯ï¼Œè¯·ç¨åå†è¯•é’±åŒ…æ”¯ä»˜
        </div>
      )}
    </div>
  );
  };

  return (
    <div className="w-full max-w-4xl bg-white rounded-3xl shadow-2xl border border-slate-100 font-sans relative h-[90vh] flex flex-col overflow-hidden">
      {/* é¡¶éƒ¨å“ç‰Œ */}
      <div className="bg-slate-50/80 px-6 py-4 flex justify-between items-center border-b border-slate-100 backdrop-blur-sm sticky top-0 z-20">
        <AgentrixLogo size="sm" showText />
        <div className="flex items-center gap-3">
          <div className="text-xs font-mono text-slate-400">SECURE v7.0</div>
          {onCancel && (
            <button
              type="button"
              onClick={() => onCancel()}
              className="text-slate-400 hover:text-slate-600 transition-colors"
              aria-label="å…³é—­æ”¯ä»˜çª—å£"
            >
              <XIcon size={16} />
            </button>
          )}
        </div>
      </div>

      {/* è®¢å•åŒº */}
      <div className="px-6 py-6 overflow-y-auto flex-1">
        <div className="flex justify-between items-end mb-8">
          <div>
            <div className="text-xs text-slate-400 mb-1 uppercase tracking-wider">Total Due</div>
            <div className="text-3xl font-extrabold text-slate-900 flex items-baseline gap-1">
              {(() => {
                const currency = order.currency || 'USDC';
                const symbol = currency === 'CNY' ? 'Â¥' : currency === 'USD' ? '$' : currency === 'EUR' ? 'â‚¬' : currency === 'GBP' ? 'Â£' : currency === 'JPY' ? 'Â¥' : '$';
                return (
                  <>
                    {symbol}{order.amount.toFixed(currency === 'JPY' ? 0 : 2)}{' '}
                    <span className="text-sm font-medium text-slate-400">{currency}</span>
                  </>
                );
              })()}
            </div>
          </div>
          <div className="text-right">
            <div className="text-xs text-slate-500 font-medium bg-slate-100 px-2 py-1 rounded-full">
              {order.description}
            </div>
          </div>
        </div>

        {/* æ±‡ç‡æ˜¾ç¤ºï¼ˆå•†å®¶æŒ‚æ³•å¸ï¼Œç”¨æˆ·é€‰æ‹©æ•°å­—è´§å¸æ”¯ä»˜ï¼‰ */}
        {(() => {
          const currency = order.currency || 'USDC';
          const shouldShowExchangeRate =
            isFiatOrderCurrency &&
            merchantAllowsCrypto &&
            (routeType === 'wallet' || routeType === 'quickpay') &&
            exchangeRate !== null &&
            cryptoAmount !== null;

          if (shouldShowExchangeRate) {
            const symbol =
              currency === 'CNY'
                ? 'Â¥'
                : currency === 'USD'
                ? '$'
                : currency === 'EUR'
                ? 'â‚¬'
                : currency === 'GBP'
                ? 'Â£'
                : currency === 'JPY'
                ? 'Â¥'
                : '$';
            return (
              <div className="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-100">
                <div className="flex items-center justify-between mb-2">
                  <div className="text-sm text-slate-600">
                    åŸä»·: {symbol}
                    {order.amount.toFixed(currency === 'JPY' ? 0 : 2)} {currency}
                  </div>
                  {isLoadingExchangeRate && (
                    <Loader2 className="animate-spin text-blue-600" size={16} />
                  )}
                </div>
                <div className="text-xl font-bold text-slate-900 mb-1">
                  â‰ˆ {cryptoAmount?.toFixed(6)} USDT
                </div>
                <div className="text-xs text-slate-500 flex items-center justify-between">
                  <span>
                    æ±‡ç‡: 1 {currency} = {exchangeRate?.toFixed(6)} USDT
                  </span>
                  {exchangeRateLockId && (
                    <span className="text-green-600 font-medium">âœ“ å·²é”å®š</span>
                  )}
                </div>
                {!exchangeRateLockId && (
                  <div className="text-xs text-amber-600 mt-2">
                    âš ï¸ æ±‡ç‡å®æ—¶æ›´æ–°ï¼Œæ”¯ä»˜æ—¶å°†ä½¿ç”¨é”å®šæ±‡ç‡
                  </div>
                )}
              </div>
            );
          }
          return null;
        })()}

        {/* çŠ¶æ€æœºæ¸²æŸ“ */}
        {status === 'loading' && (
          <div className="flex flex-col items-center justify-center py-12">
            <Loader2 className="animate-spin text-indigo-600 mb-4" size={32} />
            <div className="text-sm text-slate-500">Analyzing payment options...</div>
          </div>
        )}

        {status === 'ready' && (
          <>
            {/* æ˜¾ç¤ºå½“å‰æ”¯ä»˜æ–¹å¼çŠ¶æ€ */}
            <div className="mb-4 p-3 bg-slate-50 rounded-lg border border-slate-200">
              <div className="flex flex-col gap-2 text-xs">
                <div className="flex items-center justify-between">
                  <span className="text-slate-500">å½“å‰ç½‘ç»œ:</span>
                  <span className="font-medium text-slate-700">
                    {TESTNET_NETWORK.name} ({TESTNET_NETWORK.chainIdHex})
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-slate-500">å½“å‰æ”¯ä»˜æ–¹å¼:</span>
                  <span className="font-medium text-slate-700">
                    {routeType === 'quickpay'
                      ? 'âš¡ QuickPay å…å¯†'
                      : routeType === 'wallet'
                      ? 'ğŸ’¼ Crypto é’±åŒ…'
                      : 'ğŸ’³ æ³•å¸æ”¯ä»˜'}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-slate-500">é’±åŒ…çŠ¶æ€:</span>
                  {isConnected && defaultWallet ? (
                    <span className="text-green-600">
                      âœ“ å·²è¿æ¥ ({defaultWallet.address.slice(0, 6)}...{defaultWallet.address.slice(-4)})
                    </span>
                  ) : (
                    <span className="text-yellow-600">âš  æœªè¿æ¥é’±åŒ…</span>
                  )}
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-slate-500">QuickPay å…å¯†é¢åº¦:</span>
                  {(currentSession || activeSession) ? (
                    <span className="text-green-600">âœ“ å·²æ¿€æ´»</span>
                  ) : (
                    <span className="text-slate-400">- æœªåˆ›å»º</span>
                  )}
                </div>
                {/* æç¤ºå¯ä»¥åˆ›å»º QuickPay Sessionï¼ˆå³ä½¿ quickPayAvailable ä¸º falseï¼Œåªè¦æœ‰é’±åŒ…è¿æ¥ï¼‰ */}
                {!(currentSession || activeSession) && isConnected && defaultWallet && (
                  <div className="mt-2 p-2 bg-indigo-50 border border-indigo-200 rounded text-xs text-indigo-700">
                    ğŸ’¡ {preflightResult?.quickPayAvailable
                      ? 'æ‚¨ç¬¦åˆ QuickPay æ¡ä»¶ï¼Œåˆ›å»ºå…å¯†é¢åº¦åå³å¯ä¸€é”®æ”¯ä»˜'
                      : 'å¼€å¯ QuickPay å…å¯†é¢åº¦å¯äº«å—æ— éœ€é’±åŒ…ç¡®è®¤çš„å°é¢æ”¯ä»˜ä½“éªŒ'}
                    <button
                      type="button"
                      onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('ğŸ”µ QuickPay guide button clicked');
                        setShowQuickPayGuide(true);
                      }}
                      className="ml-2 text-indigo-600 underline hover:text-indigo-800 font-medium cursor-pointer"
                    >
                      ç«‹å³åˆ›å»º
                    </button>
                  </div>
                )}
                <div className="mt-2 p-2 bg-amber-50 border border-amber-100 rounded text-[11px] text-amber-700">
                  âš  å½“å‰ä¸ºæµ‹è¯•ç¯å¢ƒï¼Œæ‰€æœ‰æ”¯ä»˜å‡åœ¨ {TESTNET_NETWORK.name} ä¸Šæ‰§è¡Œï¼Œè¯·ä½¿ç”¨æµ‹è¯• USDTï¼ˆ6 ä½å°æ•°ï¼‰ä¸è¶³å¤Ÿçš„ BNB Gasã€‚
                </div>
              </div>
            </div>

            {merchantAllowsCrypto ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <QuickPayView />
                <WalletView />
              </div>
            ) : (
              <div>
                {routeType === 'quickpay' && <QuickPayView />}
                {routeType === 'wallet' && <WalletView />}
              </div>
            )}
          </>
        )}

        {status === 'success' && (
          <div className="flex flex-col items-center justify-center py-12">
            <CheckCircle2 className="text-green-500 mb-4" size={48} />
            <div className="text-lg font-bold text-slate-900 mb-2">Payment Successful!</div>
            <div className="text-sm text-slate-500">Your payment has been confirmed</div>
          </div>
        )}

        {status === 'error' && error && (
          <div className="bg-red-50 border border-red-200 rounded-xl p-4 mb-4">
            <div className="flex items-center gap-2 text-red-700">
              <AlertCircle size={20} />
              <span className="font-medium">Payment Failed</span>
            </div>
            <div className="text-sm text-red-600 mt-2">{error}</div>
            <div className="mt-3 flex flex-wrap gap-2">
              <button
                type="button"
                onClick={() => {
                  setError(null);
                  setStatus('loading');
                  // retry last action
                  try {
                    // attempt a conservative retry of handlePay if available
                    if (typeof (handlePay as any) === 'function') {
                      (handlePay as any)();
                    }
                  } catch (e) {
                    console.warn('Retry failed', e);
                    setStatus('error');
                  }
                }}
                className="rounded-lg px-3 py-2 bg-rose-600 text-white text-sm font-medium hover:bg-rose-500"
              >
                é‡è¯•
              </button>
              <button
                type="button"
                onClick={() => {
                  setError(null);
                  setRouteType('provider');
                  setShowProviderModal(true);
                }}
                className="rounded-lg px-3 py-2 border border-slate-200 text-sm font-medium hover:bg-slate-50"
              >
                åˆ‡æ¢é€šé“
              </button>
              <button
                type="button"
                onClick={() => window.open('mailto:support@agentrix.top?subject=æ”¯ä»˜é—®é¢˜&body=è¯·æä¾›è®¢å•IDå’Œé”™è¯¯è¯¦æƒ…', '_blank')}
                className="rounded-lg px-3 py-2 border border-transparent bg-white/80 text-sm font-medium hover:bg-white"
              >
                è”ç³»å®¢æœ
              </button>
            </div>
          </div>
        )}

        {status === 'ready' && hasFiatOptions && (
          <div className="mt-6">
            <div className="rounded-2xl border border-slate-100 bg-gradient-to-br from-white to-slate-50 p-5 shadow-sm">
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <p className="text-[11px] font-semibold uppercase tracking-[0.3em] text-slate-400">æ³•å¸é€šé“</p>
                  <h4 className="text-lg font-semibold text-slate-900 mt-1">æ²¡æœ‰é’±åŒ…ï¼Ÿä½¿ç”¨é“¶è¡Œå¡ / Apple Pay / Google Pay</h4>
                  <p className="text-xs text-slate-500">é‡‘é¢å·²é”å®šï¼ŒåŒ…å« On-Ramp è´¹ç‡ä¸ Agentrix 0.1% å¹³å°è´¹</p>
                </div>
                <button
                  type="button"
                  onClick={() => handleProviderPay('transak', selectedProviderOption || providerOptions[0])}
                  className="inline-flex items-center justify-center rounded-xl bg-slate-900 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-slate-800"
                >
                  æ³•å¸æ”¯ä»˜
                </button>
              </div>

              <div className="mt-4 grid gap-3">
                {topFiatOptions.map((option) => {
                  const disabled = option.available === false;
                  return (
                    <button
                      key={option.id}
                      type="button"
                      disabled={disabled}
                      onClick={() => handleProviderPay(option.id as any, option)}
                      className={`w-full rounded-xl border px-4 py-3 text-left transition ${
                        disabled ? 'border-slate-100 bg-slate-50 opacity-70 cursor-not-allowed' : 'border-slate-200 bg-white hover:border-slate-300'
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="flex items-center gap-2 text-sm font-semibold text-slate-800">
                            {option.name}
                            <span className={`rounded-full px-2 py-0.5 text-[11px] font-medium ${
                              option.requiresKYC ? 'bg-amber-100 text-amber-700' : 'bg-emerald-100 text-emerald-700'
                            }`}>
                              {option.requiresKYC ? 'éœ€ KYC' : 'å… KYC'}
                            </span>
                          </div>
                          <div className="text-[11px] text-slate-500 mt-1">
                            Powered by {option.provider?.toUpperCase?.() || 'Transak'}
                            {option.minAmount && option.available === false && (
                              <span className="ml-2 text-red-500">æœ€ä½ {formatFiatAmount(option.minAmount, option.currency)}</span>
                            )}
                          </div>
                        </div>
                        <div className="text-right">
                          <div className="text-base font-bold text-slate-900">
                            {formatFiatAmount(option.price, option.currency)}
                          </div>
                          <div className="text-[11px] text-slate-500">
                            è´¹ç”¨ {option.fee ? `${formatFiatSymbol(option.currency)}${option.fee.toFixed(2)}` : 'è·å–ä¸­'}
                          </div>
                        </div>
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        )}

        {/* KYC å¼•å¯¼å¼¹çª— */}
        {showKYCGuide && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-2xl p-6 max-w-md w-full">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-bold text-slate-900">éœ€è¦å®Œæˆ KYC è®¤è¯</h3>
                <button
                  onClick={() => setShowKYCGuide(false)}
                  className="text-slate-400 hover:text-slate-600"
                >
                  <XIcon size={20} />
                </button>
              </div>
              <div className="mb-6">
                <p className="text-sm text-slate-600 mb-4">
                  ä¸ºäº†ä½¿ç”¨é“¶è¡Œå¡æ”¯ä»˜ï¼Œæ‚¨éœ€è¦å®Œæˆèº«ä»½éªŒè¯ï¼ˆKYCï¼‰ã€‚è¿™é€šå¸¸åªéœ€è¦å‡ åˆ†é’Ÿæ—¶é—´ã€‚
                </p>
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <div className="text-sm font-medium text-blue-900 mb-2">éœ€è¦å‡†å¤‡çš„ææ–™ï¼š</div>
                  <ul className="text-xs text-blue-700 space-y-1">
                    <li>â€¢ èº«ä»½è¯æˆ–æŠ¤ç…§ç…§ç‰‡</li>
                    <li>â€¢ åœ°å€è¯æ˜ï¼ˆå¦‚æ°´ç”µè´¹è´¦å•ï¼‰</li>
                    <li>â€¢ è‡ªæ‹ç…§ç‰‡ï¼ˆç”¨äºäººè„¸è¯†åˆ«ï¼‰</li>
                  </ul>
                </div>
              </div>
              <div className="flex gap-3">
                <button
                  onClick={() => {
                    setShowKYCGuide(false);
                    router.push('/app/merchant/kyc');
                  }}
                  className="flex-1 bg-indigo-600 text-white py-3 rounded-lg font-medium hover:bg-indigo-700 transition-colors"
                >
                  å¼€å§‹ KYC è®¤è¯
                </button>
                <button
                  onClick={() => setShowKYCGuide(false)}
                  className="px-4 py-3 text-slate-600 hover:text-slate-800"
                >
                  ç¨å
                </button>
              </div>
            </div>
          </div>
        )}

        {/* QuickPay å¼•å¯¼å¼¹çª— */}
        {showQuickPayGuide && (
          <div 
            className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowQuickPayGuide(false);
              }
            }}
          >
            <div className="bg-white rounded-2xl p-6 max-w-md w-full">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-bold text-slate-900">å¯ç”¨ QuickPay</h3>
                <button
                  onClick={() => setShowQuickPayGuide(false)}
                  className="text-slate-400 hover:text-slate-600"
                >
                  <XIcon size={20} />
                </button>
              </div>
              <div className="mb-6">
                <div className="bg-indigo-50 border border-indigo-100 rounded-lg p-4 mb-4">
                  <div className="flex items-center gap-2 mb-2">
                    <Zap className="text-indigo-600" size={20} />
                    <div className="text-sm font-medium text-indigo-900">QuickPay çš„ä¼˜åŠ¿</div>
                  </div>
                  <ul className="text-xs text-indigo-700 space-y-1">
                    <li>â€¢ æ— éœ€é’±åŒ…ç¡®è®¤ï¼Œä¸€é”®æ”¯ä»˜</li>
                    <li>â€¢ é›¶ Gas è´¹ç”¨</li>
                    <li>â€¢ å³æ—¶åˆ°è´¦</li>
                    <li>â€¢ å®‰å…¨å¯é ï¼Œç”±æ‚¨çš„é’±åŒ…æˆæƒ</li>
                  </ul>
                </div>
                <p className="text-sm text-slate-600">
                  æ‚¨ç¬¦åˆ QuickPay ä½¿ç”¨æ¡ä»¶ï¼Œä½†è¿˜æ²¡æœ‰åˆ›å»º Sessionã€‚åˆ›å»º Session åï¼Œæ‚¨å°±å¯ä»¥äº«å—å¿«é€Ÿæ”¯ä»˜ä½“éªŒäº†ã€‚
                </p>
              </div>
              <div className="flex gap-3">
                <button
                  onClick={() => {
                    setShowQuickPayGuide(false);
                    setShowSessionManager(true);
                  }}
                  className="flex-1 bg-indigo-600 text-white py-3 rounded-lg font-medium hover:bg-indigo-700 transition-colors"
                >
                  åˆ›å»º Session
                </button>
                <button
                  onClick={() => {
                    setShowQuickPayGuide(false);
                    setRouteType('wallet');
                  }}
                  className="px-4 py-3 text-slate-600 hover:text-slate-800"
                >
                  ä½¿ç”¨é’±åŒ…æ”¯ä»˜
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Session Manager å¼¹çª— */}
        {showSessionManager && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-2xl p-6 max-w-lg w-full max-h-[90vh] overflow-y-auto">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-bold text-slate-900">åˆ›å»º QuickPay Session</h3>
                <button
                  onClick={() => {
                    setShowSessionManager(false);
                    // åˆ›å»ºæˆåŠŸåé‡æ–°åŠ è½½ Session
                    loadActiveSession().then((session) => {
                      if (session) {
                        setCurrentSession(session);
                        setRouteType('quickpay');
                      }
                    });
                  }}
                  className="text-slate-400 hover:text-slate-600"
                >
                  <XIcon size={20} />
                </button>
              </div>
              <SessionManager
                onClose={() => {
                  setShowSessionManager(false);
                  loadActiveSession().then((session) => {
                    if (session) {
                      setCurrentSession(session);
                      setRouteType('quickpay');
                    }
                  });
                }}
              />
            </div>
          </div>
        )}

        <TransakWhiteLabelModal
          open={showProviderModal}
          order={order}
          providerOption={selectedProviderOption || preflightResult?.providerOptions?.[0] || null}
          providerOptions={providerOptions}
          userProfile={userProfile}
          onClose={() => {
            setShowProviderModal(false);
            setError(null);
          }}
          onSuccess={(result) => {
            setStatus('success');
            setShowProviderModal(false);
            if (onSuccess) {
              onSuccess(result);
            }
          }}
          onError={(message) => {
            setError(message);
            setStatus('error');
          }}
        />
      </div>
    </div>
  );
}

