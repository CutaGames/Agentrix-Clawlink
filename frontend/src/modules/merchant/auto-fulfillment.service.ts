import { Injectable, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { validate as isUUID } from 'uuid';
import { Order, OrderStatus, AssetType } from '../../entities/order.entity';
import { Payment, PaymentStatus } from '../../entities/payment.entity';
import { NotificationService } from '../notification/notification.service';
import { LogisticsService } from '../logistics/logistics.service';
import { getSettlementConfig } from '../commission/financial-architecture.config';

export interface FulfillmentRecord {
  id: string;
  orderId: string;
  paymentId: string;
  merchantId: string;
  type: 'physical' | 'virtual' | 'service';
  status: 'pending' | 'fulfilled' | 'shipped' | 'delivered';
  trackingNumber?: string;
  fulfilledAt?: Date;
  metadata?: any;
}

@Injectable()
export class AutoFulfillmentService {
  private readonly logger = new Logger(AutoFulfillmentService.name);

  constructor(
    @InjectRepository(Order)
    private orderRepository: Repository<Order>,
    @InjectRepository(Payment)
    private paymentRepository: Repository<Payment>,
    @Inject(forwardRef(() => NotificationService))
    private notificationService: NotificationService,
    @Inject(forwardRef(() => LogisticsService))
    private logisticsService: LogisticsService,
  ) {}

  /**
   * 自动发货（支付成功后触发）
   */
  async autoFulfill(paymentId: string): Promise<FulfillmentRecord | null> {
    if (!isUUID(paymentId)) {
      this.logger.warn(`无效支付ID，跳过自动履约: ${paymentId}`);
      return null;
    }

    const payment = await this.paymentRepository.findOne({
      where: { id: paymentId },
    });

    if (!payment || payment.status !== PaymentStatus.COMPLETED) {
      return null;
    }

    // 查找关联的订单（从metadata中获取orderId）
    const orderId = payment.metadata?.orderId;
    if (!orderId) {
      this.logger.warn(`支付记录中没有订单ID: paymentId=${paymentId}`);
      return null;
    }

    const order = await this.orderRepository.findOne({
      where: { id: orderId },
    });

    if (!order) {
      this.logger.warn(`订单不存在: paymentId=${paymentId}`);
      return null;
    }

    // 判断订单类型
    const orderType = order.metadata?.orderType || order.metadata?.type || 'product';

    // 虚拟商品自动核销
    if (orderType === 'virtual' || orderType === 'nft') {
      return await this.fulfillVirtualProduct(order, payment);
    }

    // 实物商品生成发货单
    if (orderType === 'product' || orderType === 'physical') {
      return await this.fulfillPhysicalProduct(order, payment);
    }

    // 服务类订单自动激活
    if (orderType === 'service') {
      return await this.fulfillService(order, payment);
    }

    return null;
  }

  /**
   * 虚拟商品自动核销
   */
  private async fulfillVirtualProduct(
    order: Order,
    payment: Payment,
  ): Promise<FulfillmentRecord> {
    // 更新订单状态为已交付（即时交付）
    order.status = OrderStatus.DELIVERED;
    const settlementConfig = getSettlementConfig(order.assetType || AssetType.VIRTUAL);
    order.settlementTriggerTime = new Date();
    if (settlementConfig && typeof settlementConfig.lockupDays === 'number') {
      const dueTime = new Date(order.settlementTriggerTime!);
      dueTime.setDate(dueTime.getDate() + settlementConfig.lockupDays);
      order.settlementDueTime = dueTime;
    }
    await this.orderRepository.save(order);

    const fulfillment: FulfillmentRecord = {
      id: `fulfill_${order.id}`,
      orderId: order.id,
      paymentId: payment.id,
      merchantId: order.merchantId,
      type: 'virtual',
      status: 'fulfilled',
      fulfilledAt: new Date(),
      metadata: {
        autoFulfilled: true,
        productType: order.metadata?.orderType,
      },
    };

    this.logger.log(`虚拟商品自动核销: orderId=${order.id}, paymentId=${payment.id}`);
    return fulfillment;
  }

  /**
   * 实物商品生成发货单
   */
  private async fulfillPhysicalProduct(
    order: Order,
    payment: Payment,
  ): Promise<FulfillmentRecord> {
    // 生成发货单（实际应该调用物流服务）
    const fulfillment: FulfillmentRecord = {
      id: `fulfill_${order.id}`,
      orderId: order.id,
      paymentId: payment.id,
      merchantId: order.merchantId,
      type: 'physical',
      status: 'pending',
      metadata: {
        shippingAddress: order.metadata?.shippingAddress,
        autoGenerated: true,
      },
    };

    // 更新订单状态为履约中
    order.status = OrderStatus.PROCESSING;
    
    // 创建初始物流跟踪记录
    try {
      await this.logisticsService.updateLogisticsStatus(
        order.id,
        'packed',
        undefined, // 物流单号由商家后续填写
        undefined, // 承运商由商家后续填写
      );
    } catch (error) {
      this.logger.warn(`创建物流跟踪失败: ${error.message}`);
    }

    await this.orderRepository.save(order);

    // 发送发货通知给用户
    try {
      await this.notificationService.createNotification(order.userId, {
        type: 'order' as any,
        title: '订单已准备发货',
        message: `您的订单 ${order.id} 已准备发货，商家正在打包中。`,
        actionUrl: `/app/user/orders/${order.id}`,
        metadata: {
          orderId: order.id,
          fulfillmentId: fulfillment.id,
        },
      });
    } catch (error) {
      this.logger.warn(`发送发货通知失败: ${error.message}`);
    }

    this.logger.log(`实物商品发货单生成: orderId=${order.id}, paymentId=${payment.id}`);
    return fulfillment;
  }

  /**
   * 服务类订单自动激活
   */
  private async fulfillService(
    order: Order,
    payment: Payment,
  ): Promise<FulfillmentRecord> {
    // 服务自动激活即视为交付
    order.status = OrderStatus.DELIVERED;
    const settlementConfig = getSettlementConfig(order.assetType || AssetType.SERVICE);
    order.settlementTriggerTime = new Date();
    if (settlementConfig && typeof settlementConfig.lockupDays === 'number') {
      const dueTime = new Date(order.settlementTriggerTime!);
      dueTime.setDate(dueTime.getDate() + settlementConfig.lockupDays);
      order.settlementDueTime = dueTime;
    }
    await this.orderRepository.save(order);

    const fulfillment: FulfillmentRecord = {
      id: `fulfill_${order.id}`,
      orderId: order.id,
      paymentId: payment.id,
      merchantId: order.merchantId,
      type: 'service',
      status: 'fulfilled',
      fulfilledAt: new Date(),
      metadata: {
        serviceActivated: true,
        activationDate: new Date(),
      },
    };

    this.logger.log(`服务自动激活: orderId=${order.id}, paymentId=${payment.id}`);
    return fulfillment;
  }

  /**
   * 获取发货记录
   */
  async getFulfillmentRecords(merchantId: string): Promise<FulfillmentRecord[]> {
    // 实际应该从数据库查询
    // 这里简化处理
    return [];
  }
}

