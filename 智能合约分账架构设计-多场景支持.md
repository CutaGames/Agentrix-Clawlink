# æ™ºèƒ½åˆçº¦åˆ†è´¦æ¶æ„è®¾è®¡ - å¤šåœºæ™¯æ”¯æŒ

**ç‰ˆæœ¬**: V2.0  
**æ—¥æœŸ**: 2025å¹´1æœˆ  
**ç›®æ ‡**: è®¾è®¡æ”¯æŒå¤šç§æ”¯ä»˜åœºæ™¯çš„æ™ºèƒ½åˆçº¦åˆ†è´¦æ¶æ„ï¼ŒProvider ä½œä¸ºå¯é€‰æ¨¡å—

---

## ğŸ“‹ ç›®å½•

1. [æ”¯ä»˜åœºæ™¯åˆ†æ](#1-æ”¯ä»˜åœºæ™¯åˆ†æ)
2. [æ¶æ„è®¾è®¡](#2-æ¶æ„è®¾è®¡)
3. [åˆçº¦è®¾è®¡](#3-åˆçº¦è®¾è®¡)
4. [Provider æŠ½è±¡å±‚](#4-provider-æŠ½è±¡å±‚)
5. [å®æ–½è®¡åˆ’](#5-å®æ–½è®¡åˆ’)

---

## 1. æ”¯ä»˜åœºæ™¯åˆ†æ

### 1.1 æ”¯ä»˜åœºæ™¯åˆ†ç±»

#### åœºæ™¯ 1: QuickPay (X402) - ä¸éœ€è¦ Provider
```
ç”¨æˆ· â†’ QuickPay Session â†’ æ™ºèƒ½åˆçº¦ â†’ è‡ªåŠ¨åˆ†è´¦
```
- âœ… ç”¨æˆ·å·²æœ‰ USDC
- âœ… é€šè¿‡ Session Key æˆæƒ
- âœ… ç›´æ¥è°ƒç”¨åˆçº¦åˆ†è´¦

#### åœºæ™¯ 2: é’±åŒ…è½¬è´¦ - ä¸éœ€è¦ Provider
```
ç”¨æˆ·é’±åŒ… â†’ æ™ºèƒ½åˆçº¦ â†’ è‡ªåŠ¨åˆ†è´¦
```
- âœ… ç”¨æˆ·å·²æœ‰ USDC
- âœ… ç”¨æˆ·ç›´æ¥è½¬è´¦åˆ°åˆçº¦
- âœ… åˆçº¦è‡ªåŠ¨åˆ†è´¦

#### åœºæ™¯ 3: æ³•å¸è½¬æ•°å­—è´§å¸ - éœ€è¦ Provider
```
ç”¨æˆ·æ³•å¸ â†’ Provider â†’ è½¬æ¢ä¸º USDC â†’ æ™ºèƒ½åˆçº¦ â†’ è‡ªåŠ¨åˆ†è´¦
```
- âš ï¸ ç”¨æˆ·æ²¡æœ‰ USDC
- âš ï¸ éœ€è¦é€šè¿‡ Provider è½¬æ¢
- âœ… Provider è½¬æ¢åå‘é€ USDC åˆ°åˆçº¦

#### åœºæ™¯ 4: æ•°å­—è´§å¸è½¬æ³•å¸ - éœ€è¦ Provider
```
å•†æˆ· MPC é’±åŒ… â†’ Off-ramp Provider â†’ é“¶è¡Œè´¦æˆ·
```
- âš ï¸ å•†æˆ·éœ€è¦æç°åˆ°æ³•å¸
- âš ï¸ éœ€è¦é€šè¿‡ Off-ramp Provider
- âœ… å•†æˆ· MPC é’±åŒ…ç­¾ååå‘é€åˆ° Provider

### 1.2 åœºæ™¯æ€»ç»“

| åœºæ™¯ | éœ€è¦ Provider | æ”¯ä»˜æ–¹å¼ | åˆ†è´¦æ–¹å¼ |
|------|--------------|---------|---------|
| **QuickPay** | âŒ ä¸éœ€è¦ | X402 Session | åˆçº¦è‡ªåŠ¨åˆ†è´¦ |
| **é’±åŒ…è½¬è´¦** | âŒ ä¸éœ€è¦ | ç›´æ¥è½¬è´¦ | åˆçº¦è‡ªåŠ¨åˆ†è´¦ |
| **æ³•å¸è½¬æ•°å­—è´§å¸** | âœ… éœ€è¦ | Provider On-ramp | Provider â†’ åˆçº¦ â†’ è‡ªåŠ¨åˆ†è´¦ |
| **æ•°å­—è´§å¸è½¬æ³•å¸** | âœ… éœ€è¦ | Provider Off-ramp | å•†æˆ· MPC é’±åŒ… â†’ Provider |

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æ”¯ä»˜åœºæ™¯è·¯ç”±å±‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚              â”‚              â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
â”‚QuickPayâ”‚   â”‚é’±åŒ…è½¬è´¦â”‚      â”‚Providerâ”‚      â”‚å…¶ä»–åœºæ™¯â”‚
â”‚(X402) â”‚   â”‚       â”‚      â”‚On-rampâ”‚      â”‚       â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”˜   â””â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚           â”‚              â”‚              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   æ™ºèƒ½åˆçº¦åˆ†è´¦å±‚         â”‚
        â”‚  (Commission.sol)     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                        â”‚
    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”              â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
    â”‚å•†æˆ·MPC â”‚              â”‚Agent  â”‚
    â”‚é’±åŒ…    â”‚              â”‚é’±åŒ…   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **ç»Ÿä¸€åˆ†è´¦æ¥å£**: æ‰€æœ‰åœºæ™¯æœ€ç»ˆéƒ½è°ƒç”¨åŒä¸€ä¸ªåˆ†è´¦å‡½æ•°
2. **Provider æŠ½è±¡**: Provider ä½œä¸ºå¯é€‰æ¨¡å—ï¼Œä¸å½±å“å…¶ä»–åœºæ™¯
3. **é“¾ä¸Šè®¡ç®—**: åˆ†è´¦é€»è¾‘åœ¨é“¾ä¸Šï¼Œå¯å®¡è®¡
4. **å‘åå…¼å®¹**: å…¼å®¹ç°æœ‰ `distributeCommission` å‡½æ•°

---

## 3. åˆçº¦è®¾è®¡

### 3.1 æ ¸å¿ƒåˆçº¦ç»“æ„

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title Commission
 * @dev ç»Ÿä¸€çš„åˆ†è´¦åˆçº¦ï¼Œæ”¯æŒå¤šç§æ”¯ä»˜åœºæ™¯
 */
contract Commission is Ownable, ReentrancyGuard {
    IERC20 public settlementToken; // USDC
    address public paymindTreasury;
    address public systemRebatePool;
    
    // æ”¯ä»˜åœºæ™¯æšä¸¾
    enum PaymentScenario {
        QUICKPAY,      // QuickPay (X402)
        WALLET,        // é’±åŒ…ç›´æ¥è½¬è´¦
        PROVIDER_FIAT, // Provider æ³•å¸è½¬æ•°å­—è´§å¸
        PROVIDER_CRYPTO // Provider æ•°å­—è´§å¸è½¬æ³•å¸ï¼ˆæç°ï¼‰
    }
    
    // åˆ†è´¦é…ç½®ï¼ˆé“¾ä¸Šå­˜å‚¨ï¼‰
    struct SplitConfig {
        address merchantMPCWallet;  // å•†æˆ· MPC é’±åŒ…åœ°å€
        uint256 merchantAmount;     // å•†æˆ·é‡‘é¢
        address referrer;            // æ¨èäººåœ°å€
        uint256 referralFee;         // æ¨èäººä½£é‡‘
        address executor;            // æ‰§è¡ŒAgentåœ°å€
        uint256 executionFee;        // æ‰§è¡ŒAgentä½£é‡‘
        uint256 platformFee;         // å¹³å°è´¹ç”¨
        bool executorHasWallet;      // æ‰§è¡ŒAgentæ˜¯å¦æœ‰é’±åŒ…
        uint256 settlementTime;      // ç»“ç®—æ—¶é—´ï¼ˆ0è¡¨ç¤ºå³æ—¶ç»“ç®—ï¼‰
        bool isDisputed;             // æ˜¯å¦æœ‰äº‰è®®
    }
    
    // è®¢å•åˆ†è´¦é…ç½®
    mapping(bytes32 => SplitConfig) public orderSplitConfigs;
    
    // Provider ç™½åå•ï¼ˆå¯é€‰ï¼Œåªæœ‰éœ€è¦ Provider çš„åœºæ™¯æ‰éœ€è¦ï¼‰
    mapping(address => bool) public authorizedProviders;
    
    // äº‹ä»¶
    event PaymentReceived(
        bytes32 indexed orderId,
        PaymentScenario scenario,
        address indexed from,
        uint256 amount
    );
    
    event PaymentAutoSplit(
        bytes32 indexed orderId,
        address indexed merchantWallet,
        uint256 totalAmount,
        uint256 merchantAmount,
        uint256 platformFee,
        uint256 executionFee,
        uint256 referralFee
    );
    
    event SplitConfigSet(bytes32 indexed orderId, SplitConfig config);
    event ProviderAuthorized(address indexed provider, bool authorized);
    
    // ============ æ ¸å¿ƒåˆ†è´¦å‡½æ•° ============
    
    /**
     * @dev ç»Ÿä¸€çš„åˆ†è´¦å‡½æ•°ï¼ˆå†…éƒ¨å‡½æ•°ï¼‰
     * @param orderId è®¢å•ID
     * @param totalAmount æ€»é‡‘é¢
     */
    function _autoSplit(bytes32 orderId, uint256 totalAmount) internal {
        SplitConfig storage config = orderSplitConfigs[orderId];
        require(config.merchantMPCWallet != address(0), "Order config not found");
        require(!config.isDisputed, "Order is disputed");
        
        // éªŒè¯ç»“ç®—æ—¶é—´ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (config.settlementTime > 0) {
            require(
                block.timestamp >= config.settlementTime,
                "Settlement time not reached"
            );
        }
        
        // éªŒè¯ USDC ä½™é¢
        require(
            settlementToken.balanceOf(address(this)) >= totalAmount,
            "Insufficient USDC balance"
        );
        
        // åˆ†è´¦åˆ°å•†æˆ· MPC é’±åŒ…
        if (config.merchantMPCWallet != address(0) && config.merchantAmount > 0) {
            settlementToken.transfer(config.merchantMPCWallet, config.merchantAmount);
        }
        
        // åˆ†è´¦åˆ°æ¨èäºº
        if (config.referralFee > 0 && config.referrer != address(0)) {
            settlementToken.transfer(config.referrer, config.referralFee);
        }
        
        // åˆ†è´¦åˆ°æ‰§è¡ŒAgent
        if (config.executionFee > 0) {
            address target = config.executorHasWallet 
                ? config.executor 
                : systemRebatePool;
            if (target == address(0)) {
                target = paymindTreasury;
            }
            settlementToken.transfer(target, config.executionFee);
        }
        
        // åˆ†è´¦åˆ°å¹³å°
        if (config.platformFee > 0) {
            settlementToken.transfer(paymindTreasury, config.platformFee);
        }
        
        // è®°å½•åˆ†è´¦äº‹ä»¶
        emit PaymentAutoSplit(
            orderId,
            config.merchantMPCWallet,
            totalAmount,
            config.merchantAmount,
            config.platformFee,
            config.executionFee,
            config.referralFee
        );
    }
    
    // ============ åœºæ™¯ 1: QuickPay (X402) ============
    
    /**
     * @dev QuickPay æ”¯ä»˜ï¼ˆX402 Sessionï¼‰
     * @param orderId è®¢å•ID
     * @param amount æ”¯ä»˜é‡‘é¢
     * @param signature Session ç­¾å
     */
    function quickPaySplit(
        bytes32 orderId,
        uint256 amount,
        bytes memory signature
    ) external nonReentrant {
        // 1. éªŒè¯ Session ç­¾åï¼ˆç”± X402 åˆçº¦éªŒè¯ï¼‰
        // è¿™é‡Œå¯ä»¥è°ƒç”¨ ERC8004SessionManager éªŒè¯
        
        // 2. ä»ç”¨æˆ·é’±åŒ…è½¬è´¦ USDC åˆ°åˆçº¦
        require(
            settlementToken.transferFrom(msg.sender, address(this), amount),
            "USDC transfer failed"
        );
        
        // 3. è®°å½•æ”¯ä»˜
        emit PaymentReceived(orderId, PaymentScenario.QUICKPAY, msg.sender, amount);
        
        // 4. è‡ªåŠ¨åˆ†è´¦
        _autoSplit(orderId, amount);
    }
    
    // ============ åœºæ™¯ 2: é’±åŒ…ç›´æ¥è½¬è´¦ ============
    
    /**
     * @dev é’±åŒ…ç›´æ¥è½¬è´¦åˆ†è´¦
     * @param orderId è®¢å•ID
     * @param amount æ”¯ä»˜é‡‘é¢
     */
    function walletSplit(
        bytes32 orderId,
        uint256 amount
    ) external nonReentrant {
        // 1. ä»ç”¨æˆ·é’±åŒ…è½¬è´¦ USDC åˆ°åˆçº¦
        require(
            settlementToken.transferFrom(msg.sender, address(this), amount),
            "USDC transfer failed"
        );
        
        // 2. è®°å½•æ”¯ä»˜
        emit PaymentReceived(orderId, PaymentScenario.WALLET, msg.sender, amount);
        
        // 3. è‡ªåŠ¨åˆ†è´¦
        _autoSplit(orderId, amount);
    }
    
    // ============ åœºæ™¯ 3: Provider æ³•å¸è½¬æ•°å­—è´§å¸ ============
    
    /**
     * @dev Provider å‘é€ USDC åˆ°åˆçº¦å¹¶è‡ªåŠ¨åˆ†è´¦
     * @param orderId è®¢å•ID
     * @param amount æ”¯ä»˜é‡‘é¢
     */
    function providerFiatToCryptoSplit(
        bytes32 orderId,
        uint256 amount
    ) external nonReentrant {
        // 1. éªŒè¯ Provider åœ°å€ï¼ˆç™½åå•ï¼‰
        require(authorizedProviders[msg.sender], "Unauthorized provider");
        
        // 2. éªŒè¯ USDC å·²è½¬å…¥åˆçº¦ï¼ˆProvider éœ€è¦å…ˆ approve å’Œ transferï¼‰
        require(
            settlementToken.balanceOf(address(this)) >= amount,
            "Insufficient USDC balance"
        );
        
        // 3. è®°å½•æ”¯ä»˜
        emit PaymentReceived(orderId, PaymentScenario.PROVIDER_FIAT, msg.sender, amount);
        
        // 4. è‡ªåŠ¨åˆ†è´¦
        _autoSplit(orderId, amount);
    }
    
    // ============ åœºæ™¯ 4: æ•°å­—è´§å¸è½¬æ³•å¸ï¼ˆæç°ï¼‰============
    // è¿™ä¸ªåœºæ™¯ä¸éœ€è¦åˆ†è´¦ï¼Œæ˜¯å•†æˆ·ä» MPC é’±åŒ…æç°åˆ°æ³•å¸
    // ç”±å•†æˆ· MPC é’±åŒ…ç›´æ¥ä¸ Provider äº¤äº’ï¼Œä¸ç»è¿‡æ­¤åˆçº¦
    
    // ============ é…ç½®å‡½æ•° ============
    
    /**
     * @dev è®¾ç½®è®¢å•åˆ†è´¦é…ç½®
     * @param orderId è®¢å•ID
     * @param config åˆ†è´¦é…ç½®
     */
    function setSplitConfig(
        bytes32 orderId,
        SplitConfig memory config
    ) external onlyOwner {
        require(config.merchantMPCWallet != address(0), "Invalid merchant wallet");
        orderSplitConfigs[orderId] = config;
        emit SplitConfigSet(orderId, config);
    }
    
    /**
     * @dev è®¾ç½® Provider ç™½åå•ï¼ˆå¯é€‰ï¼‰
     */
    function setAuthorizedProvider(address provider, bool authorized) external onlyOwner {
        authorizedProviders[provider] = authorized;
        emit ProviderAuthorized(provider, authorized);
    }
    
    /**
     * @dev è®¾ç½®äº‰è®®çŠ¶æ€
     */
    function setDisputeStatus(bytes32 orderId, bool isDisputed) external onlyOwner {
        SplitConfig storage config = orderSplitConfigs[orderId];
        require(config.merchantMPCWallet != address(0), "Order not found");
        config.isDisputed = isDisputed;
    }
    
    // ============ å…¼å®¹ç°æœ‰å‡½æ•° ============
    
    /**
     * @dev å…¼å®¹ç°æœ‰çš„ distributeCommission å‡½æ•°
     * ä¿æŒå‘åå…¼å®¹ï¼Œä½†æ¨èä½¿ç”¨æ–°çš„è‡ªåŠ¨åˆ†è´¦å‡½æ•°
     */
    function distributeCommission(bytes32 orderId) external nonReentrant {
        SplitConfig storage config = orderSplitConfigs[orderId];
        require(config.merchantMPCWallet != address(0), "Order not found");
        
        // è·å–åˆçº¦ä¸­çš„ USDC ä½™é¢ï¼ˆéœ€è¦å…ˆæœ‰èµ„é‡‘è½¬å…¥ï¼‰
        uint256 contractBalance = settlementToken.balanceOf(address(this));
        require(contractBalance > 0, "No balance to distribute");
        
        // ä½¿ç”¨é…ç½®ä¸­çš„é‡‘é¢ï¼Œæˆ–ä½¿ç”¨åˆçº¦ä½™é¢
        uint256 totalAmount = config.merchantAmount + 
                             config.referralFee + 
                             config.executionFee + 
                             config.platformFee;
        
        // å¦‚æœé…ç½®é‡‘é¢ä¸º0ï¼Œä½¿ç”¨åˆçº¦ä½™é¢
        if (totalAmount == 0) {
            totalAmount = contractBalance;
        }
        
        // è‡ªåŠ¨åˆ†è´¦
        _autoSplit(orderId, totalAmount);
    }
    
    // ============ æŸ¥è¯¢å‡½æ•° ============
    
    /**
     * @dev æŸ¥è¯¢è®¢å•åˆ†è´¦é…ç½®
     */
    function getSplitConfig(bytes32 orderId) 
        external 
        view 
        returns (SplitConfig memory) 
    {
        return orderSplitConfigs[orderId];
    }
    
    /**
     * @dev æŸ¥è¯¢åˆçº¦ USDC ä½™é¢
     */
    function getContractBalance() external view returns (uint256) {
        return settlementToken.balanceOf(address(this));
    }
    
    /**
     * @dev æ¥æ”¶ ERC20 ä»£å¸ï¼ˆç”¨äºé’±åŒ…ç›´æ¥è½¬è´¦åœºæ™¯ï¼‰
     */
    function receiveERC20(address token, uint256 amount) external {
        // è¿™ä¸ªå‡½æ•°å¯ä»¥ç”±ç”¨æˆ·ç›´æ¥è°ƒç”¨ï¼Œå°† USDC è½¬å…¥åˆçº¦
        // ä½†éœ€è¦é…åˆ setSplitConfig å’Œ walletSplit ä½¿ç”¨
        require(token == address(settlementToken), "Only USDC allowed");
        require(
            IERC20(token).transferFrom(msg.sender, address(this), amount),
            "Transfer failed"
        );
    }
}
```

---

## 4. Provider æŠ½è±¡å±‚

### 4.1 Provider æ¥å£è®¾è®¡

```typescript
// backend/src/modules/payment/provider-abstract.service.ts

/**
 * Provider æŠ½è±¡æ¥å£
 * ç”¨äºç»Ÿä¸€ç®¡ç†ä¸åŒçš„ Providerï¼Œæ–¹ä¾¿åç»­æ¥å…¥å’Œæµ‹è¯•
 */
export interface IProvider {
  // Provider æ ‡è¯†
  id: string;
  name: string;
  
  // æ˜¯å¦æ”¯æŒ On-rampï¼ˆæ³•å¸è½¬æ•°å­—è´§å¸ï¼‰
  supportsOnRamp: boolean;
  
  // æ˜¯å¦æ”¯æŒ Off-rampï¼ˆæ•°å­—è´§å¸è½¬æ³•å¸ï¼‰
  supportsOffRamp: boolean;
  
  // è·å–æŠ¥ä»·
  getQuote(amount: number, fromCurrency: string, toCurrency: string): Promise<ProviderQuote>;
  
  // æ‰§è¡Œ On-rampï¼ˆæ³•å¸è½¬æ•°å­—è´§å¸ï¼‰
  executeOnRamp?(params: OnRampParams): Promise<OnRampResult>;
  
  // æ‰§è¡Œ Off-rampï¼ˆæ•°å­—è´§å¸è½¬æ³•å¸ï¼‰
  executeOffRamp?(params: OffRampParams): Promise<OffRampResult>;
}

/**
 * Mock Providerï¼ˆç”¨äºæµ‹è¯•ï¼Œä¸å½±å“å…¶ä»–åœºæ™¯ï¼‰
 */
@Injectable()
export class MockProviderService implements IProvider {
  id = 'mock';
  name = 'Mock Provider';
  supportsOnRamp = true;
  supportsOffRamp = true;
  
  async getQuote(amount: number, fromCurrency: string, toCurrency: string): Promise<ProviderQuote> {
    // è¿”å›æ¨¡æ‹ŸæŠ¥ä»·
    return {
      providerId: this.id,
      rate: 1.0, // 1:1 æ±‡ç‡ï¼ˆæµ‹è¯•ç”¨ï¼‰
      fee: amount * 0.03, // 3% æ‰‹ç»­è´¹
      estimatedAmount: amount * 0.97,
      expiresAt: new Date(Date.now() + 60000), // 1åˆ†é’Ÿè¿‡æœŸ
    };
  }
  
  async executeOnRamp(params: OnRampParams): Promise<OnRampResult> {
    // æ¨¡æ‹Ÿ On-ramp æµç¨‹
    // åœ¨å®é™…åœºæ™¯ä¸­ï¼Œè¿™é‡Œä¼šè°ƒç”¨çœŸå®çš„ Provider API
    // åœ¨æµ‹è¯•åœºæ™¯ä¸­ï¼Œå¯ä»¥æ¨¡æ‹Ÿè¿”å›æˆåŠŸ
    
    return {
      transactionId: `mock-${Date.now()}`,
      status: 'completed',
      cryptoAmount: params.amount * 0.97,
      cryptoCurrency: 'USDC',
      // æ³¨æ„ï¼šåœ¨æµ‹è¯•ä¸­ï¼Œéœ€è¦æ‰‹åŠ¨ mint USDC åˆ°åˆçº¦åœ°å€
      // æˆ–ä½¿ç”¨æµ‹è¯•è´¦æˆ·è½¬è´¦
    };
  }
}

/**
 * Provider ç®¡ç†å™¨
 */
@Injectable()
export class ProviderManagerService {
  private providers: Map<string, IProvider> = new Map();
  
  constructor() {
    // æ³¨å†Œ Mock Providerï¼ˆç”¨äºæµ‹è¯•ï¼‰
    this.registerProvider(new MockProviderService());
    
    // åç»­å¯ä»¥æ³¨å†ŒçœŸå® Provider
    // this.registerProvider(new MoonPayProviderService());
    // this.registerProvider(new TransakProviderService());
  }
  
  registerProvider(provider: IProvider) {
    this.providers.set(provider.id, provider);
  }
  
  getProvider(providerId: string): IProvider | null {
    return this.providers.get(providerId) || null;
  }
  
  /**
   * è·å–æ‰€æœ‰æ”¯æŒ On-ramp çš„ Provider
   */
  getOnRampProviders(): IProvider[] {
    return Array.from(this.providers.values())
      .filter(p => p.supportsOnRamp);
  }
  
  /**
   * è·å–æ‰€æœ‰æ”¯æŒ Off-ramp çš„ Provider
   */
  getOffRampProviders(): IProvider[] {
    return Array.from(this.providers.values())
      .filter(p => p.supportsOffRamp);
  }
  
  /**
   * é€‰æ‹©æœ€ä¼˜ Providerï¼ˆæ¯”ä»·ï¼‰
   */
  async selectBestProvider(
    amount: number,
    fromCurrency: string,
    toCurrency: string,
    type: 'onramp' | 'offramp'
  ): Promise<IProvider | null> {
    const candidates = type === 'onramp' 
      ? this.getOnRampProviders()
      : this.getOffRampProviders();
    
    if (candidates.length === 0) {
      return null;
    }
    
    // è·å–æ‰€æœ‰ Provider çš„æŠ¥ä»·
    const quotes = await Promise.all(
      candidates.map(async (provider) => {
        try {
          const quote = await provider.getQuote(amount, fromCurrency, toCurrency);
          return { provider, quote };
        } catch (error) {
          return null;
        }
      })
    );
    
    // è¿‡æ»¤å¤±è´¥çš„æŠ¥ä»·
    const validQuotes = quotes.filter(q => q !== null);
    
    if (validQuotes.length === 0) {
      return null;
    }
    
    // é€‰æ‹©æœ€ä¼˜æŠ¥ä»·ï¼ˆè´¹ç‡æœ€ä½ï¼‰
    const best = validQuotes.reduce((best, current) => {
      const bestRate = best.quote.rate;
      const currentRate = current.quote.rate;
      return currentRate > bestRate ? current : best;
    });
    
    return best.provider;
  }
}
```

### 4.2 Provider æµ‹è¯•æ¨¡å¼

```typescript
// ç¯å¢ƒå˜é‡æ§åˆ¶
const USE_MOCK_PROVIDER = process.env.USE_MOCK_PROVIDER === 'true';
const PROVIDER_MODE = process.env.PROVIDER_MODE || 'mock'; // 'mock' | 'real'

// åœ¨æ”¯ä»˜æœåŠ¡ä¸­ä½¿ç”¨
@Injectable()
export class PaymentService {
  constructor(
    private providerManager: ProviderManagerService,
  ) {}
  
  async processProviderPayment(dto: ProcessPaymentDto) {
    // å¦‚æœæ˜¯æµ‹è¯•æ¨¡å¼ï¼Œä½¿ç”¨ Mock Provider
    if (PROVIDER_MODE === 'mock') {
      const mockProvider = this.providerManager.getProvider('mock');
      if (mockProvider) {
        // ä½¿ç”¨ Mock Provider å¤„ç†
        // åœ¨æµ‹è¯•ä¸­ï¼Œå¯ä»¥æ‰‹åŠ¨ mint USDC æˆ–ä½¿ç”¨æµ‹è¯•è´¦æˆ·
        return this.processWithMockProvider(mockProvider, dto);
      }
    }
    
    // å¦åˆ™ä½¿ç”¨çœŸå® Provider
    const provider = await this.providerManager.selectBestProvider(
      dto.amount,
      dto.currency,
      'USDC',
      'onramp'
    );
    
    if (!provider) {
      throw new Error('No provider available');
    }
    
    return this.processWithRealProvider(provider, dto);
  }
}
```

---

## 5. å®æ–½è®¡åˆ’

### 5.1 é˜¶æ®µ 1: æ ¸å¿ƒåˆ†è´¦åŠŸèƒ½ï¼ˆ1-2å‘¨ï¼‰

**ç›®æ ‡**: å®ç° QuickPay å’Œé’±åŒ…è½¬è´¦åœºæ™¯çš„åˆ†è´¦

**ä»»åŠ¡**:
1. âœ… ä¿®æ”¹ `Commission.sol`ï¼Œæ·»åŠ ç»Ÿä¸€åˆ†è´¦å‡½æ•° `_autoSplit`
2. âœ… å®ç° `quickPaySplit` å‡½æ•°ï¼ˆQuickPay åœºæ™¯ï¼‰
3. âœ… å®ç° `walletSplit` å‡½æ•°ï¼ˆé’±åŒ…è½¬è´¦åœºæ™¯ï¼‰
4. âœ… å®ç° `setSplitConfig` å‡½æ•°ï¼ˆè®¾ç½®åˆ†è´¦é…ç½®ï¼‰
5. âœ… ä¿æŒ `distributeCommission` å‘åå…¼å®¹

**æµ‹è¯•**:
- QuickPay æ”¯ä»˜æµ‹è¯•
- é’±åŒ…è½¬è´¦æµ‹è¯•
- åˆ†è´¦éªŒè¯æµ‹è¯•

### 5.2 é˜¶æ®µ 2: Provider æŠ½è±¡å±‚ï¼ˆ1å‘¨ï¼‰

**ç›®æ ‡**: å®ç° Provider æŠ½è±¡å±‚ï¼Œä¸å½±å“å…¶ä»–åœºæ™¯

**ä»»åŠ¡**:
1. âœ… åˆ›å»º `IProvider` æ¥å£
2. âœ… å®ç° `MockProviderService`ï¼ˆç”¨äºæµ‹è¯•ï¼‰
3. âœ… å®ç° `ProviderManagerService`ï¼ˆProvider ç®¡ç†å™¨ï¼‰
4. âœ… é›†æˆåˆ°æ”¯ä»˜æœåŠ¡

**æµ‹è¯•**:
- Mock Provider æµ‹è¯•
- Provider åˆ‡æ¢æµ‹è¯•

### 5.3 é˜¶æ®µ 3: Provider é›†æˆï¼ˆå¯é€‰ï¼Œåç»­ï¼‰

**ç›®æ ‡**: æ¥å…¥çœŸå® Provider

**ä»»åŠ¡**:
1. å®ç°çœŸå® Providerï¼ˆMoonPayã€Transak ç­‰ï¼‰
2. å®ç° `providerFiatToCryptoSplit` å‡½æ•°
3. é›†æˆ Provider API

**æµ‹è¯•**:
- Provider On-ramp æµ‹è¯•
- Provider Off-ramp æµ‹è¯•

---

## 6. æµ‹è¯•æ–¹æ¡ˆ

### 6.1 æµ‹è¯•åœºæ™¯ä¼˜å…ˆçº§

**ä¼˜å…ˆçº§ 1: ä¸éœ€è¦ Provider çš„åœºæ™¯**
1. âœ… QuickPay (X402) æ”¯ä»˜å’Œåˆ†è´¦
2. âœ… é’±åŒ…ç›´æ¥è½¬è´¦å’Œåˆ†è´¦
3. âœ… åˆ†è´¦é…ç½®è®¾ç½®å’ŒæŸ¥è¯¢

**ä¼˜å…ˆçº§ 2: Provider åœºæ™¯ï¼ˆä½¿ç”¨ Mockï¼‰**
4. âš ï¸ Provider æ³•å¸è½¬æ•°å­—è´§å¸ï¼ˆä½¿ç”¨ Mock Providerï¼‰
5. âš ï¸ Provider æ•°å­—è´§å¸è½¬æ³•å¸ï¼ˆä½¿ç”¨ Mock Providerï¼‰

**ä¼˜å…ˆçº§ 3: çœŸå® Providerï¼ˆåç»­ï¼‰**
6. â³ çœŸå® Provider é›†æˆå’Œæµ‹è¯•

### 6.2 æµ‹è¯•ç”¨ä¾‹

```typescript
// contract/test/Commission.test.ts

describe('Commission - Multi-Scenario Split', () => {
  describe('Scenario 1: QuickPay', () => {
    it('should split payment via QuickPay', async () => {
      // 1. è®¾ç½®åˆ†è´¦é…ç½®
      await commission.setSplitConfig(orderId, splitConfig);
      
      // 2. ç”¨æˆ·æˆæƒ USDC
      await usdc.approve(commission.address, amount);
      
      // 3. è°ƒç”¨ QuickPay åˆ†è´¦
      await commission.quickPaySplit(orderId, amount, signature);
      
      // 4. éªŒè¯åˆ†è´¦ç»“æœ
      expect(await usdc.balanceOf(merchantWallet)).to.equal(merchantAmount);
      expect(await usdc.balanceOf(platformWallet)).to.equal(platformFee);
    });
  });
  
  describe('Scenario 2: Wallet Transfer', () => {
    it('should split payment via wallet transfer', async () => {
      // 1. è®¾ç½®åˆ†è´¦é…ç½®
      await commission.setSplitConfig(orderId, splitConfig);
      
      // 2. ç”¨æˆ·æˆæƒå¹¶è½¬è´¦
      await usdc.approve(commission.address, amount);
      await commission.walletSplit(orderId, amount);
      
      // 3. éªŒè¯åˆ†è´¦ç»“æœ
      expect(await usdc.balanceOf(merchantWallet)).to.equal(merchantAmount);
    });
  });
  
  describe('Scenario 3: Provider (Mock)', () => {
    it('should split payment from Provider', async () => {
      // 1. è®¾ç½®åˆ†è´¦é…ç½®
      await commission.setSplitConfig(orderId, splitConfig);
      
      // 2. è®¾ç½® Provider ç™½åå•
      await commission.setAuthorizedProvider(mockProviderAddress, true);
      
      // 3. Provider è½¬è´¦ USDC åˆ°åˆçº¦
      await usdc.transfer(commission.address, amount);
      
      // 4. Provider è°ƒç”¨åˆ†è´¦å‡½æ•°
      await commission.providerFiatToCryptoSplit(orderId, amount);
      
      // 5. éªŒè¯åˆ†è´¦ç»“æœ
      expect(await usdc.balanceOf(merchantWallet)).to.equal(merchantAmount);
    });
  });
});
```

---

## 7. æ€»ç»“

### 7.1 è®¾è®¡ä¼˜åŠ¿

âœ… **ç»Ÿä¸€åˆ†è´¦æ¥å£**: æ‰€æœ‰åœºæ™¯ä½¿ç”¨åŒä¸€ä¸ªåˆ†è´¦é€»è¾‘  
âœ… **Provider æŠ½è±¡**: Provider ä½œä¸ºå¯é€‰æ¨¡å—ï¼Œä¸å½±å“å…¶ä»–åœºæ™¯  
âœ… **æµ‹è¯•å‹å¥½**: ä½¿ç”¨ Mock Providerï¼Œå¯ä»¥å…ˆæµ‹è¯•å…¶ä»–åœºæ™¯  
âœ… **å‘åå…¼å®¹**: ä¿æŒç°æœ‰ `distributeCommission` å‡½æ•°  
âœ… **é“¾ä¸Šè®¡ç®—**: åˆ†è´¦é€»è¾‘åœ¨é“¾ä¸Šï¼Œå¯å®¡è®¡

### 7.2 å®æ–½å»ºè®®

**ç«‹å³å®æ–½**:
1. ä¿®æ”¹ `Commission.sol`ï¼Œæ·»åŠ ç»Ÿä¸€åˆ†è´¦å‡½æ•°
2. å®ç° QuickPay å’Œé’±åŒ…è½¬è´¦åœºæ™¯
3. å®ç° Provider æŠ½è±¡å±‚ï¼ˆMock Providerï¼‰

**åç»­å®æ–½**:
4. æ¥å…¥çœŸå® Provider
5. å®ç° Provider On-ramp å’Œ Off-ramp

**æµ‹è¯•ç­–ç•¥**:
- å…ˆæµ‹è¯•ä¸éœ€è¦ Provider çš„åœºæ™¯ï¼ˆQuickPayã€é’±åŒ…è½¬è´¦ï¼‰
- ä½¿ç”¨ Mock Provider æµ‹è¯• Provider åœºæ™¯
- åç»­å†æ¥å…¥çœŸå® Provider

---

**æ–‡æ¡£ç»´æŠ¤**: PayMind å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

