/**
 * Workspace Service
 * 
 * 工作区服务 - 文件浏览、编辑、Agent 协作
 */

import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Workspace, WorkspaceType } from './entities/workspace.entity';
import { WorkspaceFile } from './entities/workspace-file.entity';
import { HqAIService, ChatMessage } from '../ai/hq-ai.service';
import { KnowledgeService } from '../knowledge/knowledge.service';
import * as fs from 'fs';
import * as path from 'path';

export interface FileTreeNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  children?: FileTreeNode[];
  language?: string;
  size?: number;
}

export interface CreateWorkspaceDto {
  name: string;
  rootPath: string;
  description?: string;
  type?: WorkspaceType;
}

export interface AgentChatDto {
  workspaceId: string;
  agentCode: string;
  message: string;
  filePath?: string;
  selectedCode?: string;
}

export interface AgentChatResponse {
  agentCode: string;
  response: string;
  suggestedChanges?: {
    filePath: string;
    oldCode: string;
    newCode: string;
    explanation: string;
  }[];
}

@Injectable()
export class WorkspaceService {
  private readonly logger = new Logger(WorkspaceService.name);

  // 排除的目录和文件
  private readonly excludePatterns = [
    'node_modules',
    '.git',
    '.next',
    'dist',
    'build',
    '.cache',
    '__pycache__',
    '.DS_Store',
    'coverage',
    '.nyc_output',
  ];

  // 语言映射
  private readonly languageMap: Record<string, string> = {
    '.ts': 'typescript',
    '.tsx': 'typescript',
    '.js': 'javascript',
    '.jsx': 'javascript',
    '.py': 'python',
    '.json': 'json',
    '.md': 'markdown',
    '.css': 'css',
    '.scss': 'scss',
    '.html': 'html',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.sql': 'sql',
    '.sh': 'shell',
    '.env': 'dotenv',
  };

  constructor(
    @InjectRepository(Workspace)
    private workspaceRepo: Repository<Workspace>,
    @InjectRepository(WorkspaceFile)
    private fileRepo: Repository<WorkspaceFile>,
    private aiService: HqAIService,
    private knowledgeService: KnowledgeService,
  ) {}

  /**
   * 创建工作区
   */
  async createWorkspace(dto: CreateWorkspaceDto): Promise<Workspace> {
    const { name, rootPath, description, type } = dto;

    // 验证路径存在
    if (!fs.existsSync(rootPath)) {
      throw new BadRequestException(`Path does not exist: ${rootPath}`);
    }

    const workspace = this.workspaceRepo.create({
      name,
      rootPath,
      description,
      type: type || WorkspaceType.PROJECT,
      isActive: true,
      settings: {
        defaultAgent: 'ARCHITECT-01',
        autoSave: true,
        excludePatterns: this.excludePatterns,
      },
    });

    return this.workspaceRepo.save(workspace);
  }

  /**
   * 获取所有工作区
   */
  async findAllWorkspaces(): Promise<Workspace[]> {
    return this.workspaceRepo.find({
      where: { isActive: true },
      order: { updatedAt: 'DESC' },
    });
  }

  /**
   * 获取单个工作区
   */
  async findWorkspace(id: string): Promise<Workspace> {
    const workspace = await this.workspaceRepo.findOne({
      where: { id },
      relations: ['files'],
    });
    if (!workspace) {
      throw new NotFoundException(`Workspace not found: ${id}`);
    }
    return workspace;
  }

  /**
   * 获取文件树
   */
  async getFileTree(workspaceId: string, subPath: string = ''): Promise<FileTreeNode[]> {
    const workspace = await this.findWorkspace(workspaceId);
    const targetPath = path.join(workspace.rootPath, subPath);

    if (!fs.existsSync(targetPath)) {
      throw new NotFoundException(`Path not found: ${targetPath}`);
    }

    return this.buildFileTree(targetPath, workspace.settings?.excludePatterns || this.excludePatterns);
  }

  /**
   * 构建文件树
   */
  private buildFileTree(dirPath: string, excludePatterns: string[], depth: number = 0): FileTreeNode[] {
    if (depth > 5) return []; // 限制深度

    const entries = fs.readdirSync(dirPath, { withFileTypes: true });
    const result: FileTreeNode[] = [];

    for (const entry of entries) {
      // 排除模式
      if (excludePatterns.some(p => entry.name === p || entry.name.startsWith('.'))) {
        continue;
      }

      const fullPath = path.join(dirPath, entry.name);
      const node: FileTreeNode = {
        name: entry.name,
        path: fullPath,
        type: entry.isDirectory() ? 'directory' : 'file',
      };

      if (entry.isDirectory()) {
        node.children = this.buildFileTree(fullPath, excludePatterns, depth + 1);
      } else {
        const ext = path.extname(entry.name);
        node.language = this.languageMap[ext] || 'plaintext';
        try {
          const stats = fs.statSync(fullPath);
          node.size = stats.size;
        } catch {}
      }

      result.push(node);
    }

    // 排序：目录在前，文件在后，按名称排序
    return result.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type === 'directory' ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
  }

  /**
   * 读取文件内容
   */
  async readFile(workspaceId: string, filePath: string): Promise<{
    content: string;
    language: string;
    fileName: string;
  }> {
    const workspace = await this.findWorkspace(workspaceId);
    
    // 确保文件在工作区内
    const absolutePath = path.resolve(filePath);
    if (!absolutePath.startsWith(path.resolve(workspace.rootPath))) {
      throw new BadRequestException('File is outside workspace');
    }

    if (!fs.existsSync(absolutePath)) {
      throw new NotFoundException(`File not found: ${filePath}`);
    }

    const content = fs.readFileSync(absolutePath, 'utf-8');
    const ext = path.extname(absolutePath);
    const fileName = path.basename(absolutePath);

    // 记录打开的文件
    await this.trackOpenFile(workspaceId, absolutePath, content);

    return {
      content,
      language: this.languageMap[ext] || 'plaintext',
      fileName,
    };
  }

  /**
   * 保存文件
   */
  async saveFile(workspaceId: string, filePath: string, content: string): Promise<{ success: boolean }> {
    const workspace = await this.findWorkspace(workspaceId);
    
    const absolutePath = path.resolve(filePath);
    if (!absolutePath.startsWith(path.resolve(workspace.rootPath))) {
      throw new BadRequestException('File is outside workspace');
    }

    fs.writeFileSync(absolutePath, content, 'utf-8');
    
    // 更新追踪
    const file = await this.fileRepo.findOne({
      where: { workspaceId, filePath: absolutePath },
    });
    if (file) {
      file.content = content;
      file.isDirty = false;
      await this.fileRepo.save(file);
    }

    return { success: true };
  }

  /**
   * 追踪打开的文件
   */
  private async trackOpenFile(workspaceId: string, filePath: string, content: string): Promise<void> {
    let file = await this.fileRepo.findOne({
      where: { workspaceId, filePath },
    });

    if (!file) {
      file = this.fileRepo.create({
        workspaceId,
        filePath,
        fileName: path.basename(filePath),
        language: this.languageMap[path.extname(filePath)] || 'plaintext',
        isOpen: true,
        content,
      });
    } else {
      file.isOpen = true;
      file.content = content;
    }

    await this.fileRepo.save(file);
  }

  /**
   * 与 Agent 聊天（代码协作）
   */
  async chatWithAgent(dto: AgentChatDto): Promise<AgentChatResponse> {
    const { workspaceId, agentCode, message, filePath, selectedCode } = dto;
    
    const workspace = await this.findWorkspace(workspaceId);
    
    // 构建上下文
    let context = '';
    
    // 添加文件上下文
    if (filePath && fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      const fileName = path.basename(filePath);
      context += `## 当前文件: ${fileName}\n\`\`\`\n${fileContent}\n\`\`\`\n\n`;
    }

    // 添加选中的代码
    if (selectedCode) {
      context += `## 选中的代码\n\`\`\`\n${selectedCode}\n\`\`\`\n\n`;
    }

    // 从知识库获取相关上下文
    const knowledgeContext = await this.knowledgeService.getContextForAgent(agentCode, message);
    if (knowledgeContext) {
      context += knowledgeContext;
    }

    // 构建系统提示
    const systemPrompts: Record<string, string> = {
      'ARCHITECT-01': `你是 Agentrix 的首席架构师，负责系统架构设计和技术决策。
当前工作区: ${workspace.name} (${workspace.rootPath})
请基于以下上下文回答用户问题，提供架构建议。

${context}`,
      'CODER-01': `你是 Agentrix 的资深开发者，精通 TypeScript/NestJS/Next.js。
当前工作区: ${workspace.name} (${workspace.rootPath})
请基于以下上下文回答用户问题，提供代码实现建议。
如果需要修改代码，请明确指出需要修改的位置和内容。

${context}`,
    };

    const systemPrompt = systemPrompts[agentCode] || `你是 Agentrix 的 AI 助手。\n${context}`;

    // 调用 AI
    const messages: ChatMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: message },
    ];

    try {
      // 存储用户消息到 Memory（与 HQ Core 共享记忆）
      const memoryContext = { agentId: agentCode, sessionId: `workspace-${workspaceId}` };
      if (this.memoryService) {
        await this.memoryService.storeConversation(memoryContext, 'user', message);
      }

      const result = await this.aiService.chatForAgent(agentCode, messages);
      
      // 存储助手响应到 Memory
      if (this.memoryService) {
        await this.memoryService.storeConversation(memoryContext, 'assistant', result.content);
      }

      return {
        agentCode,
        response: result.content,
        // TODO: 解析 AI 响应中的代码修改建议
      };
    } catch (error) {
      this.logger.error(`Agent chat failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * 获取打开的文件列表
   */
  async getOpenFiles(workspaceId: string): Promise<WorkspaceFile[]> {
    return this.fileRepo.find({
      where: { workspaceId, isOpen: true },
      order: { updatedAt: 'DESC' },
    });
  }

  /**
   * 关闭文件
   */
  async closeFile(workspaceId: string, filePath: string): Promise<void> {
    const file = await this.fileRepo.findOne({
      where: { workspaceId, filePath },
    });
    if (file) {
      file.isOpen = false;
      await this.fileRepo.save(file);
    }
  }

  /**
   * 删除工作区
   */
  async removeWorkspace(id: string): Promise<void> {
    const workspace = await this.findWorkspace(id);
    workspace.isActive = false;
    await this.workspaceRepo.save(workspace);
  }

  /**
   * 切换工作区
   */
  async switchWorkspace(workspaceId: string): Promise<Workspace> {
    return this.findWorkspace(workspaceId);
  }

  // ========== Legacy API Methods (兼容现有前端) ==========

  /**
   * 获取工作区文件树（简化版，不需要 workspaceId）
   */
  async getWorkspaceTree(depth: number = 3): Promise<FileTreeNode[]> {
    // 使用项目根目录
    const projectRoot = path.resolve(__dirname, '../../../../..');
    this.logger.log(`Getting workspace tree from: ${projectRoot}`);
    
    try {
      return this.buildFileTreeRelative(projectRoot, '', this.excludePatterns, depth, 0);
    } catch (error) {
      this.logger.error(`Failed to build file tree: ${error.message}`);
      // 返回 mock 数据作为 fallback
      return [
        { name: 'src', path: 'src', type: 'directory', children: [
          { name: 'app', path: 'src/app', type: 'directory', children: [] },
          { name: 'components', path: 'src/components', type: 'directory', children: [] },
        ]},
        { name: 'package.json', path: 'package.json', type: 'file' },
        { name: 'README.md', path: 'README.md', type: 'file' },
      ];
    }
  }

  /**
   * 构建相对路径的文件树
   */
  private buildFileTreeRelative(
    basePath: string,
    relativePath: string,
    excludePatterns: string[],
    maxDepth: number,
    currentDepth: number,
  ): FileTreeNode[] {
    if (currentDepth >= maxDepth) return [];

    const fullPath = relativePath ? path.join(basePath, relativePath) : basePath;
    
    if (!fs.existsSync(fullPath)) return [];

    const entries = fs.readdirSync(fullPath, { withFileTypes: true });
    const result: FileTreeNode[] = [];

    for (const entry of entries) {
      if (excludePatterns.some(p => entry.name === p || entry.name.startsWith('.'))) {
        continue;
      }

      const entryRelativePath = relativePath ? path.join(relativePath, entry.name) : entry.name;
      const node: FileTreeNode = {
        name: entry.name,
        path: entryRelativePath.replace(/\\/g, '/'),
        type: entry.isDirectory() ? 'directory' : 'file',
      };

      if (entry.isDirectory()) {
        node.children = this.buildFileTreeRelative(
          basePath, entryRelativePath, excludePatterns, maxDepth, currentDepth + 1,
        );
      } else {
        const ext = path.extname(entry.name);
        node.language = this.languageMap[ext] || 'plaintext';
      }

      result.push(node);
    }

    return result.sort((a, b) => {
      if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
  }

  /**
   * 获取工作区信息
   */
  async getWorkspaceInfo(): Promise<{
    projectName: string;
    gitBranch?: string;
    nodeVersion?: string;
    dependencies?: Record<string, string>;
  }> {
    const projectRoot = path.resolve(__dirname, '../../../../..');
    
    let projectName = 'Agentrix HQ';
    let gitBranch: string | undefined;
    let nodeVersion: string | undefined;
    let dependencies: Record<string, string> = {};

    // 读取 package.json
    const packageJsonPath = path.join(projectRoot, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      try {
        const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
        projectName = pkg.name || projectName;
        dependencies = pkg.dependencies || {};
      } catch {}
    }

    // 获取 git 分支
    const gitHeadPath = path.join(projectRoot, '.git', 'HEAD');
    if (fs.existsSync(gitHeadPath)) {
      try {
        const head = fs.readFileSync(gitHeadPath, 'utf-8').trim();
        if (head.startsWith('ref:')) {
          gitBranch = head.replace('ref: refs/heads/', '');
        }
      } catch {}
    }

    return { projectName, gitBranch, nodeVersion, dependencies };
  }

  /**
   * 按路径读取文件
   */
  async readFileByPath(relativePath: string): Promise<{ content: string; language: string }> {
    const projectRoot = path.resolve(__dirname, '../../../../..');
    const fullPath = path.join(projectRoot, relativePath);

    this.logger.log(`Reading file: ${fullPath}`);

    if (!fs.existsSync(fullPath)) {
      throw new NotFoundException(`File not found: ${relativePath}`);
    }

    const content = fs.readFileSync(fullPath, 'utf-8');
    const ext = path.extname(fullPath);

    return {
      content,
      language: this.languageMap[ext] || 'plaintext',
    };
  }

  /**
   * 按路径写入文件
   */
  async writeFileByPath(relativePath: string, content: string): Promise<{ success: boolean }> {
    const projectRoot = path.resolve(__dirname, '../../../../..');
    const fullPath = path.join(projectRoot, relativePath);

    this.logger.log(`Writing file: ${fullPath}`);

    // 安全检查：不允许写入项目外
    if (!fullPath.startsWith(projectRoot)) {
      throw new BadRequestException('Cannot write outside project root');
    }

    fs.writeFileSync(fullPath, content, 'utf-8');
    return { success: true };
  }

  /**
   * 执行终端命令 (受限的)
   */
  async executeCommand(command: string): Promise<{ output: string; exitCode: number }> {
    // 安全：只允许特定的命令
    const allowedPrefixes = ['npm ', 'node ', 'npx ', 'cat ', 'ls ', 'pwd', 'echo '];
    const isAllowed = allowedPrefixes.some(p => command.startsWith(p));

    if (!isAllowed) {
      return {
        output: `Command not allowed: ${command}. Only npm/node/npx/cat/ls/pwd commands are permitted.`,
        exitCode: 1,
      };
    }

    try {
      const { execSync } = await import('child_process');
      const projectRoot = path.resolve(__dirname, '../../../../..');
      const output = execSync(command, {
        cwd: projectRoot,
        encoding: 'utf-8',
        timeout: 30000,
      });
      return { output, exitCode: 0 };
    } catch (error: any) {
      return {
        output: error.stderr || error.message,
        exitCode: error.status || 1,
      };
    }
  }

  /**
   * 搜索文件内容
   */
  async searchInFiles(
    query: string,
    caseSensitive: boolean = false,
  ): Promise<{ matches: { file: string; line: number; content: string }[] }> {
    const projectRoot = path.resolve(__dirname, '../../../../..');
    const matches: { file: string; line: number; content: string }[] = [];
    const searchRegex = new RegExp(query, caseSensitive ? 'g' : 'gi');

    const searchDir = (dir: string, relativePath: string = '') => {
      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        if (this.excludePatterns.some(p => entry.name === p || entry.name.startsWith('.'))) {
          continue;
        }

        const fullPath = path.join(dir, entry.name);
        const relPath = relativePath ? `${relativePath}/${entry.name}` : entry.name;

        if (entry.isDirectory()) {
          searchDir(fullPath, relPath);
        } else if (entry.isFile()) {
          const ext = path.extname(entry.name);
          if (this.languageMap[ext]) {
            try {
              const content = fs.readFileSync(fullPath, 'utf-8');
              const lines = content.split('\n');
              lines.forEach((line, idx) => {
                if (searchRegex.test(line)) {
                  matches.push({
                    file: relPath,
                    line: idx + 1,
                    content: line.trim().substring(0, 200),
                  });
                }
              });
            } catch {}
          }
        }
      }
    };

    searchDir(projectRoot);
    return { matches: matches.slice(0, 50) }; // 限制结果数量
  }
}
